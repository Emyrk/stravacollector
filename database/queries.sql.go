// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const deleteActivity = `-- name: DeleteActivity :one
DELETE FROM
	activity_summary
WHERE
	id = $1
RETURNING id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate
`

func (q *sqlQuerier) DeleteActivity(ctx context.Context, id int64) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, deleteActivity, id)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
	)
	return i, err
}

const getActivitySummary = `-- name: GetActivitySummary :one
SELECT
	id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate
FROM
    activity_summary
WHERE
    id = $1
`

func (q *sqlQuerier) GetActivitySummary(ctx context.Context, id int64) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, getActivitySummary, id)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
	)
	return i, err
}

const updateActivityName = `-- name: UpdateActivityName :exec
UPDATE activity_summary
SET
    name = $2
WHERE
    id = $1
`

type UpdateActivityNameParams struct {
	ID   int64  `db:"id" json:"id"`
	Name string `db:"name" json:"name"`
}

func (q *sqlQuerier) UpdateActivityName(ctx context.Context, arg UpdateActivityNameParams) error {
	_, err := q.db.ExecContext(ctx, updateActivityName, arg.ID, arg.Name)
	return err
}

const upsertActivityDetail = `-- name: UpsertActivityDetail :one
INSERT INTO
	activity_detail(
		updated_at, id, athlete_id, start_latlng,
		end_latlng, from_accepted_tag, average_cadence, average_temp,
		average_watts, weighted_average_watts, kilojoules, max_watts,
	    elev_high, elev_low, suffer_score, embed_token,
	    segment_leaderboard_opt_out, leaderboard_opt_out, num_segment_efforts,
	    premium_fetch, map_id, calories
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
	 $18, $19, $20, $21)
ON CONFLICT
	(id)
	DO UPDATE SET
	updated_at = Now(),
	athlete_id = $2,
	start_latlng = $3,
	end_latlng = $4,
	from_accepted_tag = $5,
	average_cadence = $6,
	average_temp = $7,
	average_watts = $8,
	weighted_average_watts = $9,
	kilojoules = $10,
	max_watts = $11,
	elev_high = $12,
	elev_low = $13,
	suffer_score = $14,
	embed_token = $15,
	segment_leaderboard_opt_out = $16,
	leaderboard_opt_out = $17,
	num_segment_efforts = $18,
	premium_fetch = $19,
	map_id = $20,
	calories = $21
RETURNING id, athlete_id, start_latlng, end_latlng, from_accepted_tag, average_cadence, average_temp, average_watts, weighted_average_watts, kilojoules, max_watts, elev_high, elev_low, suffer_score, calories, embed_token, segment_leaderboard_opt_out, leaderboard_opt_out, num_segment_efforts, premium_fetch, updated_at, map_id
`

type UpsertActivityDetailParams struct {
	ID                       int64     `db:"id" json:"id"`
	AthleteID                int64     `db:"athlete_id" json:"athlete_id"`
	StartLatlng              []float64 `db:"start_latlng" json:"start_latlng"`
	EndLatlng                []float64 `db:"end_latlng" json:"end_latlng"`
	FromAcceptedTag          bool      `db:"from_accepted_tag" json:"from_accepted_tag"`
	AverageCadence           float64   `db:"average_cadence" json:"average_cadence"`
	AverageTemp              float64   `db:"average_temp" json:"average_temp"`
	AverageWatts             float64   `db:"average_watts" json:"average_watts"`
	WeightedAverageWatts     float64   `db:"weighted_average_watts" json:"weighted_average_watts"`
	Kilojoules               float64   `db:"kilojoules" json:"kilojoules"`
	MaxWatts                 float64   `db:"max_watts" json:"max_watts"`
	ElevHigh                 float64   `db:"elev_high" json:"elev_high"`
	ElevLow                  float64   `db:"elev_low" json:"elev_low"`
	SufferScore              int32     `db:"suffer_score" json:"suffer_score"`
	EmbedToken               string    `db:"embed_token" json:"embed_token"`
	SegmentLeaderboardOptOut bool      `db:"segment_leaderboard_opt_out" json:"segment_leaderboard_opt_out"`
	LeaderboardOptOut        bool      `db:"leaderboard_opt_out" json:"leaderboard_opt_out"`
	NumSegmentEfforts        int32     `db:"num_segment_efforts" json:"num_segment_efforts"`
	PremiumFetch             bool      `db:"premium_fetch" json:"premium_fetch"`
	MapID                    string    `db:"map_id" json:"map_id"`
	Calories                 float64   `db:"calories" json:"calories"`
}

func (q *sqlQuerier) UpsertActivityDetail(ctx context.Context, arg UpsertActivityDetailParams) (ActivityDetail, error) {
	row := q.db.QueryRowContext(ctx, upsertActivityDetail,
		arg.ID,
		arg.AthleteID,
		pq.Array(arg.StartLatlng),
		pq.Array(arg.EndLatlng),
		arg.FromAcceptedTag,
		arg.AverageCadence,
		arg.AverageTemp,
		arg.AverageWatts,
		arg.WeightedAverageWatts,
		arg.Kilojoules,
		arg.MaxWatts,
		arg.ElevHigh,
		arg.ElevLow,
		arg.SufferScore,
		arg.EmbedToken,
		arg.SegmentLeaderboardOptOut,
		arg.LeaderboardOptOut,
		arg.NumSegmentEfforts,
		arg.PremiumFetch,
		arg.MapID,
		arg.Calories,
	)
	var i ActivityDetail
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		pq.Array(&i.StartLatlng),
		pq.Array(&i.EndLatlng),
		&i.FromAcceptedTag,
		&i.AverageCadence,
		&i.AverageTemp,
		&i.AverageWatts,
		&i.WeightedAverageWatts,
		&i.Kilojoules,
		&i.MaxWatts,
		&i.ElevHigh,
		&i.ElevLow,
		&i.SufferScore,
		&i.Calories,
		&i.EmbedToken,
		&i.SegmentLeaderboardOptOut,
		&i.LeaderboardOptOut,
		&i.NumSegmentEfforts,
		&i.PremiumFetch,
		&i.UpdatedAt,
		&i.MapID,
	)
	return i, err
}

const upsertActivitySummary = `-- name: UpsertActivitySummary :one
INSERT INTO
	activity_summary(
		updated_at, id, athlete_id, upload_id, external_id, name,
	    distance, moving_time, elapsed_time, total_elevation_gain,
	    activity_type, sport_type, workout_type, start_date,
	    start_date_local, timezone, utc_offset, achievement_count,
	    kudos_count, comment_count, athlete_count, photo_count, map_id,
	    trainer, commute, manual, private, flagged, gear_id, average_speed,
	    max_speed, device_watts, has_heartrate, pr_count, total_photo_count,
	    average_heartrate, max_heartrate
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
	 $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		athlete_id = $2,
		upload_id = $3,
		external_id = $4,
		name = $5,
		distance = $6,
		moving_time = $7,
		elapsed_time = $8,
		total_elevation_gain = $9,
		activity_type = $10,
		sport_type = $11,
		workout_type = $12,
		start_date = $13,
		start_date_local = $14,
		timezone = $15,
		utc_offset = $16,
		achievement_count = $17,
		kudos_count = $18,
		comment_count = $19,
		athlete_count = $20,
		photo_count = $21,
		map_id = $22,
		trainer = $23,
		commute = $24,
		manual = $25,
		private = $26,
		flagged = $27,
		gear_id = $28,
		average_speed = $29,
		max_speed = $30,
		device_watts = $31,
		has_heartrate = $32,
		pr_count = $33,
		total_photo_count = $34,
		average_heartrate = $35,
		max_heartrate = $36
RETURNING id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate
`

type UpsertActivitySummaryParams struct {
	ID                 int64     `db:"id" json:"id"`
	AthleteID          int64     `db:"athlete_id" json:"athlete_id"`
	UploadID           int64     `db:"upload_id" json:"upload_id"`
	ExternalID         string    `db:"external_id" json:"external_id"`
	Name               string    `db:"name" json:"name"`
	Distance           float64   `db:"distance" json:"distance"`
	MovingTime         float64   `db:"moving_time" json:"moving_time"`
	ElapsedTime        float64   `db:"elapsed_time" json:"elapsed_time"`
	TotalElevationGain float64   `db:"total_elevation_gain" json:"total_elevation_gain"`
	ActivityType       string    `db:"activity_type" json:"activity_type"`
	SportType          string    `db:"sport_type" json:"sport_type"`
	WorkoutType        int32     `db:"workout_type" json:"workout_type"`
	StartDate          time.Time `db:"start_date" json:"start_date"`
	StartDateLocal     time.Time `db:"start_date_local" json:"start_date_local"`
	Timezone           string    `db:"timezone" json:"timezone"`
	UtcOffset          float64   `db:"utc_offset" json:"utc_offset"`
	AchievementCount   int32     `db:"achievement_count" json:"achievement_count"`
	KudosCount         int32     `db:"kudos_count" json:"kudos_count"`
	CommentCount       int32     `db:"comment_count" json:"comment_count"`
	AthleteCount       int32     `db:"athlete_count" json:"athlete_count"`
	PhotoCount         int32     `db:"photo_count" json:"photo_count"`
	MapID              string    `db:"map_id" json:"map_id"`
	Trainer            bool      `db:"trainer" json:"trainer"`
	Commute            bool      `db:"commute" json:"commute"`
	Manual             bool      `db:"manual" json:"manual"`
	Private            bool      `db:"private" json:"private"`
	Flagged            bool      `db:"flagged" json:"flagged"`
	GearID             string    `db:"gear_id" json:"gear_id"`
	AverageSpeed       float64   `db:"average_speed" json:"average_speed"`
	MaxSpeed           float64   `db:"max_speed" json:"max_speed"`
	DeviceWatts        bool      `db:"device_watts" json:"device_watts"`
	HasHeartrate       bool      `db:"has_heartrate" json:"has_heartrate"`
	PrCount            int32     `db:"pr_count" json:"pr_count"`
	TotalPhotoCount    int32     `db:"total_photo_count" json:"total_photo_count"`
	AverageHeartrate   float64   `db:"average_heartrate" json:"average_heartrate"`
	MaxHeartrate       float64   `db:"max_heartrate" json:"max_heartrate"`
}

func (q *sqlQuerier) UpsertActivitySummary(ctx context.Context, arg UpsertActivitySummaryParams) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, upsertActivitySummary,
		arg.ID,
		arg.AthleteID,
		arg.UploadID,
		arg.ExternalID,
		arg.Name,
		arg.Distance,
		arg.MovingTime,
		arg.ElapsedTime,
		arg.TotalElevationGain,
		arg.ActivityType,
		arg.SportType,
		arg.WorkoutType,
		arg.StartDate,
		arg.StartDateLocal,
		arg.Timezone,
		arg.UtcOffset,
		arg.AchievementCount,
		arg.KudosCount,
		arg.CommentCount,
		arg.AthleteCount,
		arg.PhotoCount,
		arg.MapID,
		arg.Trainer,
		arg.Commute,
		arg.Manual,
		arg.Private,
		arg.Flagged,
		arg.GearID,
		arg.AverageSpeed,
		arg.MaxSpeed,
		arg.DeviceWatts,
		arg.HasHeartrate,
		arg.PrCount,
		arg.TotalPhotoCount,
		arg.AverageHeartrate,
		arg.MaxHeartrate,
	)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
	)
	return i, err
}

const getAthleteLoad = `-- name: GetAthleteLoad :one
SELECT athlete_id, last_backload_activity_start, last_load_attempt, last_load_incomplete, last_load_error, activites_loaded_last_attempt, earliest_activity, earliest_activity_done FROM athlete_load WHERE athlete_id = $1
`

func (q *sqlQuerier) GetAthleteLoad(ctx context.Context, athleteID int64) (AthleteLoad, error) {
	row := q.db.QueryRowContext(ctx, getAthleteLoad, athleteID)
	var i AthleteLoad
	err := row.Scan(
		&i.AthleteID,
		&i.LastBackloadActivityStart,
		&i.LastLoadAttempt,
		&i.LastLoadIncomplete,
		&i.LastLoadError,
		&i.ActivitesLoadedLastAttempt,
		&i.EarliestActivity,
		&i.EarliestActivityDone,
	)
	return i, err
}

const getAthleteLogin = `-- name: GetAthleteLogin :one
SELECT athlete_id, summit, provider_id, created_at, updated_at, oauth_access_token, oauth_refresh_token, oauth_expiry, oauth_token_type, id FROM athlete_logins WHERE athlete_id = $1
`

func (q *sqlQuerier) GetAthleteLogin(ctx context.Context, athleteID int64) (AthleteLogin, error) {
	row := q.db.QueryRowContext(ctx, getAthleteLogin, athleteID)
	var i AthleteLogin
	err := row.Scan(
		&i.AthleteID,
		&i.Summit,
		&i.ProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthAccessToken,
		&i.OauthRefreshToken,
		&i.OauthExpiry,
		&i.OauthTokenType,
		&i.ID,
	)
	return i, err
}

const getAthleteNeedsLoad = `-- name: GetAthleteNeedsLoad :one
SELECT
    athlete_load.athlete_id, athlete_load.last_backload_activity_start, athlete_load.last_load_attempt, athlete_load.last_load_incomplete, athlete_load.last_load_error, athlete_load.activites_loaded_last_attempt, athlete_load.earliest_activity, athlete_load.earliest_activity_done, athlete_logins.athlete_id, athlete_logins.summit, athlete_logins.provider_id, athlete_logins.created_at, athlete_logins.updated_at, athlete_logins.oauth_access_token, athlete_logins.oauth_refresh_token, athlete_logins.oauth_expiry, athlete_logins.oauth_token_type, athlete_logins.id
FROM
	athlete_load
INNER JOIN
	athlete_logins
ON
    athlete_load.athlete_id = athlete_logins.athlete_id
ORDER BY
    -- Athletes with oldest load attempt first.
	(last_load_incomplete OR not earliest_activity_done, last_load_attempt)
LIMIT 1
`

type GetAthleteNeedsLoadRow struct {
	AthleteID                  int64     `db:"athlete_id" json:"athlete_id"`
	LastBackloadActivityStart  time.Time `db:"last_backload_activity_start" json:"last_backload_activity_start"`
	LastLoadAttempt            time.Time `db:"last_load_attempt" json:"last_load_attempt"`
	LastLoadIncomplete         bool      `db:"last_load_incomplete" json:"last_load_incomplete"`
	LastLoadError              string    `db:"last_load_error" json:"last_load_error"`
	ActivitesLoadedLastAttempt int32     `db:"activites_loaded_last_attempt" json:"activites_loaded_last_attempt"`
	EarliestActivity           time.Time `db:"earliest_activity" json:"earliest_activity"`
	EarliestActivityDone       bool      `db:"earliest_activity_done" json:"earliest_activity_done"`
	AthleteID_2                int64     `db:"athlete_id_2" json:"athlete_id_2"`
	Summit                     bool      `db:"summit" json:"summit"`
	ProviderID                 string    `db:"provider_id" json:"provider_id"`
	CreatedAt                  time.Time `db:"created_at" json:"created_at"`
	UpdatedAt                  time.Time `db:"updated_at" json:"updated_at"`
	OauthAccessToken           string    `db:"oauth_access_token" json:"oauth_access_token"`
	OauthRefreshToken          string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OauthExpiry                time.Time `db:"oauth_expiry" json:"oauth_expiry"`
	OauthTokenType             string    `db:"oauth_token_type" json:"oauth_token_type"`
	ID                         uuid.UUID `db:"id" json:"id"`
}

func (q *sqlQuerier) GetAthleteNeedsLoad(ctx context.Context) (GetAthleteNeedsLoadRow, error) {
	row := q.db.QueryRowContext(ctx, getAthleteNeedsLoad)
	var i GetAthleteNeedsLoadRow
	err := row.Scan(
		&i.AthleteID,
		&i.LastBackloadActivityStart,
		&i.LastLoadAttempt,
		&i.LastLoadIncomplete,
		&i.LastLoadError,
		&i.ActivitesLoadedLastAttempt,
		&i.EarliestActivity,
		&i.EarliestActivityDone,
		&i.AthleteID_2,
		&i.Summit,
		&i.ProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthAccessToken,
		&i.OauthRefreshToken,
		&i.OauthExpiry,
		&i.OauthTokenType,
		&i.ID,
	)
	return i, err
}

const upsertAthlete = `-- name: UpsertAthlete :one
INSERT INTO
	athletes(
	fetched_at, id, created_at, updated_at,
		summit, username, firstname, lastname, sex, city, state, country,
		follow_count, friend_count, measurement_preference, ftp, weight, clubs
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
ON CONFLICT
	(id)
	DO UPDATE SET
		fetched_at = Now(),
		created_at = $2,
		updated_at = $3,
		summit = $4,
		username = $5,
		firstname = $6,
		lastname = $7,
		sex = $8,
		city = $9,
		state = $10,
		country = $11,
		follow_count = $12,
		friend_count = $13,
		measurement_preference = $14,
		ftp = $15,
		weight = $16,
		clubs = $17
RETURNING id, summit, username, firstname, lastname, sex, city, state, country, follow_count, friend_count, measurement_preference, ftp, weight, clubs, created_at, updated_at, fetched_at
`

type UpsertAthleteParams struct {
	ID                    int64           `db:"id" json:"id"`
	CreatedAt             time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt             time.Time       `db:"updated_at" json:"updated_at"`
	Summit                bool            `db:"summit" json:"summit"`
	Username              string          `db:"username" json:"username"`
	Firstname             string          `db:"firstname" json:"firstname"`
	Lastname              string          `db:"lastname" json:"lastname"`
	Sex                   string          `db:"sex" json:"sex"`
	City                  string          `db:"city" json:"city"`
	State                 string          `db:"state" json:"state"`
	Country               string          `db:"country" json:"country"`
	FollowCount           int32           `db:"follow_count" json:"follow_count"`
	FriendCount           int32           `db:"friend_count" json:"friend_count"`
	MeasurementPreference string          `db:"measurement_preference" json:"measurement_preference"`
	Ftp                   float64         `db:"ftp" json:"ftp"`
	Weight                float64         `db:"weight" json:"weight"`
	Clubs                 json.RawMessage `db:"clubs" json:"clubs"`
}

func (q *sqlQuerier) UpsertAthlete(ctx context.Context, arg UpsertAthleteParams) (Athlete, error) {
	row := q.db.QueryRowContext(ctx, upsertAthlete,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Summit,
		arg.Username,
		arg.Firstname,
		arg.Lastname,
		arg.Sex,
		arg.City,
		arg.State,
		arg.Country,
		arg.FollowCount,
		arg.FriendCount,
		arg.MeasurementPreference,
		arg.Ftp,
		arg.Weight,
		arg.Clubs,
	)
	var i Athlete
	err := row.Scan(
		&i.ID,
		&i.Summit,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Sex,
		&i.City,
		&i.State,
		&i.Country,
		&i.FollowCount,
		&i.FriendCount,
		&i.MeasurementPreference,
		&i.Ftp,
		&i.Weight,
		&i.Clubs,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FetchedAt,
	)
	return i, err
}

const upsertAthleteLoad = `-- name: UpsertAthleteLoad :one
INSERT INTO
	athlete_load(
		athlete_id,
		last_backload_activity_start,
	    last_load_attempt,
		last_load_incomplete,
		last_load_error,
		activites_loaded_last_attempt,
		earliest_activity,
		earliest_activity_done
	)
VALUES
	($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT
	(athlete_id)
DO UPDATE SET
	last_backload_activity_start = $2,
	last_load_attempt = $3,
	last_load_incomplete = $4,
	last_load_error = $5,
	activites_loaded_last_attempt = $6,
	earliest_activity = $7,
	earliest_activity_done = $8
RETURNING athlete_id, last_backload_activity_start, last_load_attempt, last_load_incomplete, last_load_error, activites_loaded_last_attempt, earliest_activity, earliest_activity_done
`

type UpsertAthleteLoadParams struct {
	AthleteID                  int64     `db:"athlete_id" json:"athlete_id"`
	LastBackloadActivityStart  time.Time `db:"last_backload_activity_start" json:"last_backload_activity_start"`
	LastLoadAttempt            time.Time `db:"last_load_attempt" json:"last_load_attempt"`
	LastLoadIncomplete         bool      `db:"last_load_incomplete" json:"last_load_incomplete"`
	LastLoadError              string    `db:"last_load_error" json:"last_load_error"`
	ActivitesLoadedLastAttempt int32     `db:"activites_loaded_last_attempt" json:"activites_loaded_last_attempt"`
	EarliestActivity           time.Time `db:"earliest_activity" json:"earliest_activity"`
	EarliestActivityDone       bool      `db:"earliest_activity_done" json:"earliest_activity_done"`
}

func (q *sqlQuerier) UpsertAthleteLoad(ctx context.Context, arg UpsertAthleteLoadParams) (AthleteLoad, error) {
	row := q.db.QueryRowContext(ctx, upsertAthleteLoad,
		arg.AthleteID,
		arg.LastBackloadActivityStart,
		arg.LastLoadAttempt,
		arg.LastLoadIncomplete,
		arg.LastLoadError,
		arg.ActivitesLoadedLastAttempt,
		arg.EarliestActivity,
		arg.EarliestActivityDone,
	)
	var i AthleteLoad
	err := row.Scan(
		&i.AthleteID,
		&i.LastBackloadActivityStart,
		&i.LastLoadAttempt,
		&i.LastLoadIncomplete,
		&i.LastLoadError,
		&i.ActivitesLoadedLastAttempt,
		&i.EarliestActivity,
		&i.EarliestActivityDone,
	)
	return i, err
}

const upsertAthleteLogin = `-- name: UpsertAthleteLogin :one
INSERT INTO
	athlete_logins(
		created_at, updated_at, id,
             athlete_id, summit, provider_id, oauth_access_token,
             oauth_refresh_token, oauth_expiry, oauth_token_type
	)
VALUES
    (Now(), Now(), gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7)
ON CONFLICT
	(athlete_id)
DO UPDATE SET
	updated_at = Now(),
	summit = $2,
	provider_id = $3,
	oauth_access_token = $4,
	oauth_refresh_token = $5,
	oauth_expiry = $6,
	oauth_token_type = $7
RETURNING athlete_id, summit, provider_id, created_at, updated_at, oauth_access_token, oauth_refresh_token, oauth_expiry, oauth_token_type, id
`

type UpsertAthleteLoginParams struct {
	AthleteID         int64     `db:"athlete_id" json:"athlete_id"`
	Summit            bool      `db:"summit" json:"summit"`
	ProviderID        string    `db:"provider_id" json:"provider_id"`
	OauthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OauthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OauthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
	OauthTokenType    string    `db:"oauth_token_type" json:"oauth_token_type"`
}

func (q *sqlQuerier) UpsertAthleteLogin(ctx context.Context, arg UpsertAthleteLoginParams) (AthleteLogin, error) {
	row := q.db.QueryRowContext(ctx, upsertAthleteLogin,
		arg.AthleteID,
		arg.Summit,
		arg.ProviderID,
		arg.OauthAccessToken,
		arg.OauthRefreshToken,
		arg.OauthExpiry,
		arg.OauthTokenType,
	)
	var i AthleteLogin
	err := row.Scan(
		&i.AthleteID,
		&i.Summit,
		&i.ProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthAccessToken,
		&i.OauthRefreshToken,
		&i.OauthExpiry,
		&i.OauthTokenType,
		&i.ID,
	)
	return i, err
}

const upsertMap = `-- name: UpsertMap :one
INSERT INTO
	maps(
	updated_at, id, polyline, summary_polyline
)
VALUES
	(Now(), $1, $2, $3)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		polyline = $2,
		summary_polyline = $3
RETURNING id, polyline, summary_polyline, updated_at
`

type UpsertMapParams struct {
	ID              string `db:"id" json:"id"`
	Polyline        string `db:"polyline" json:"polyline"`
	SummaryPolyline string `db:"summary_polyline" json:"summary_polyline"`
}

func (q *sqlQuerier) UpsertMap(ctx context.Context, arg UpsertMapParams) (Map, error) {
	row := q.db.QueryRowContext(ctx, upsertMap, arg.ID, arg.Polyline, arg.SummaryPolyline)
	var i Map
	err := row.Scan(
		&i.ID,
		&i.Polyline,
		&i.SummaryPolyline,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertMapSummary = `-- name: UpsertMapSummary :one
INSERT INTO
	maps(
	updated_at, polyline, id, summary_polyline
)
VALUES
	(Now(), '', $1, $2)
ON CONFLICT
	(id)
	DO UPDATE SET
	  updated_at = Now(),
	  summary_polyline = $2
RETURNING id, polyline, summary_polyline, updated_at
`

type UpsertMapSummaryParams struct {
	ID              string `db:"id" json:"id"`
	SummaryPolyline string `db:"summary_polyline" json:"summary_polyline"`
}

func (q *sqlQuerier) UpsertMapSummary(ctx context.Context, arg UpsertMapSummaryParams) (Map, error) {
	row := q.db.QueryRowContext(ctx, upsertMapSummary, arg.ID, arg.SummaryPolyline)
	var i Map
	err := row.Scan(
		&i.ID,
		&i.Polyline,
		&i.SummaryPolyline,
		&i.UpdatedAt,
	)
	return i, err
}

const bestRouteEfforts = `-- name: BestRouteEfforts :many
SELECT
	merged.activities_id, segment_ids, sum, json_agg, hugel_efforts.id, hugel_efforts.athlete_id, hugel_efforts.segment_id, hugel_efforts.name, hugel_efforts.elapsed_time, hugel_efforts.moving_time, hugel_efforts.start_date, hugel_efforts.start_date_local, hugel_efforts.distance, hugel_efforts.start_index, hugel_efforts.end_index, hugel_efforts.device_watts, hugel_efforts.average_watts, hugel_efforts.kom_rank, hugel_efforts.pr_rank, hugel_efforts.updated_at, hugel_efforts.activities_id, segment_efforts.id, segment_efforts.athlete_id, segment_efforts.segment_id, segment_efforts.name, segment_efforts.elapsed_time, segment_efforts.moving_time, segment_efforts.start_date, segment_efforts.start_date_local, segment_efforts.distance, segment_efforts.start_index, segment_efforts.end_index, segment_efforts.device_watts, segment_efforts.average_watts, segment_efforts.kom_rank, segment_efforts.pr_rank, segment_efforts.updated_at, segment_efforts.activities_id
FROM
	(
		SELECT
			hugel_efforts.activities_id,
			-- segment_ids is all the segments this activity has efforts on.
			-- Only segments in the provided list are considered.
			array_agg(segment_id) AS segment_ids,
			-- Sum is the total time of all the efforts.
			sum(elapsed_time),
			-- A json struct containing each effort details.
			json_agg(
					json_build_object(
					    	'effort_id', id,
							'segment_id', segment_id,
							'elapsed_time', elapsed_time,
							'device_watts', device_watts,
					    	'average_watts', average_watts
						)
				)
		FROM
			(
				-- This query returns only the best effort per (segment_id, activity_id)
				SELECT DISTINCT ON (activities_id, segment_id)
					id, athlete_id, segment_id, name, elapsed_time, moving_time, start_date, start_date_local, distance, start_index, end_index, device_watts, average_watts, kom_rank, pr_rank, updated_at, activities_id
				FROM
					segment_efforts
				WHERE
				    -- ARRAY[629046, 6744304, 910045, 628785, 629546, 628842]
					segment_id = any($1 :: bigint[])
				ORDER BY
					activities_id, segment_id, elapsed_time ASC
			) as hugel_efforts
			-- Each activity will now be represented by a single aggregated row
		GROUP BY
			hugel_efforts.activities_id
	) AS merged
WHERE
	segment_ids @> $1 :: bigint[]
`

type BestRouteEffortsRow struct {
	ActivitiesID     int64           `db:"activities_id" json:"activities_id"`
	SegmentIds       interface{}     `db:"segment_ids" json:"segment_ids"`
	Sum              int64           `db:"sum" json:"sum"`
	JsonAgg          json.RawMessage `db:"json_agg" json:"json_agg"`
	ID               int64           `db:"id" json:"id"`
	AthleteID        int64           `db:"athlete_id" json:"athlete_id"`
	SegmentID        int64           `db:"segment_id" json:"segment_id"`
	Name             string          `db:"name" json:"name"`
	ElapsedTime      float64         `db:"elapsed_time" json:"elapsed_time"`
	MovingTime       float64         `db:"moving_time" json:"moving_time"`
	StartDate        time.Time       `db:"start_date" json:"start_date"`
	StartDateLocal   time.Time       `db:"start_date_local" json:"start_date_local"`
	Distance         float64         `db:"distance" json:"distance"`
	StartIndex       int32           `db:"start_index" json:"start_index"`
	EndIndex         int32           `db:"end_index" json:"end_index"`
	DeviceWatts      bool            `db:"device_watts" json:"device_watts"`
	AverageWatts     float64         `db:"average_watts" json:"average_watts"`
	KomRank          sql.NullInt32   `db:"kom_rank" json:"kom_rank"`
	PrRank           sql.NullInt32   `db:"pr_rank" json:"pr_rank"`
	UpdatedAt        time.Time       `db:"updated_at" json:"updated_at"`
	ActivitiesID_2   int64           `db:"activities_id_2" json:"activities_id_2"`
	ID_2             int64           `db:"id_2" json:"id_2"`
	AthleteID_2      int64           `db:"athlete_id_2" json:"athlete_id_2"`
	SegmentID_2      int64           `db:"segment_id_2" json:"segment_id_2"`
	Name_2           string          `db:"name_2" json:"name_2"`
	ElapsedTime_2    float64         `db:"elapsed_time_2" json:"elapsed_time_2"`
	MovingTime_2     float64         `db:"moving_time_2" json:"moving_time_2"`
	StartDate_2      time.Time       `db:"start_date_2" json:"start_date_2"`
	StartDateLocal_2 time.Time       `db:"start_date_local_2" json:"start_date_local_2"`
	Distance_2       float64         `db:"distance_2" json:"distance_2"`
	StartIndex_2     int32           `db:"start_index_2" json:"start_index_2"`
	EndIndex_2       int32           `db:"end_index_2" json:"end_index_2"`
	DeviceWatts_2    bool            `db:"device_watts_2" json:"device_watts_2"`
	AverageWatts_2   float64         `db:"average_watts_2" json:"average_watts_2"`
	KomRank_2        sql.NullInt32   `db:"kom_rank_2" json:"kom_rank_2"`
	PrRank_2         sql.NullInt32   `db:"pr_rank_2" json:"pr_rank_2"`
	UpdatedAt_2      time.Time       `db:"updated_at_2" json:"updated_at_2"`
	ActivitiesID_3   int64           `db:"activities_id_3" json:"activities_id_3"`
}

// BestRouteEfforts returns all activities that have efforts on all the provided segments.
// The returned activities include the best effort for each segment.
func (q *sqlQuerier) BestRouteEfforts(ctx context.Context, expectedSegments []int64) ([]BestRouteEffortsRow, error) {
	rows, err := q.db.QueryContext(ctx, bestRouteEfforts, pq.Array(expectedSegments))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BestRouteEffortsRow
	for rows.Next() {
		var i BestRouteEffortsRow
		if err := rows.Scan(
			&i.ActivitiesID,
			&i.SegmentIds,
			&i.Sum,
			&i.JsonAgg,
			&i.ID,
			&i.AthleteID,
			&i.SegmentID,
			&i.Name,
			&i.ElapsedTime,
			&i.MovingTime,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Distance,
			&i.StartIndex,
			&i.EndIndex,
			&i.DeviceWatts,
			&i.AverageWatts,
			&i.KomRank,
			&i.PrRank,
			&i.UpdatedAt,
			&i.ActivitiesID_2,
			&i.ID_2,
			&i.AthleteID_2,
			&i.SegmentID_2,
			&i.Name_2,
			&i.ElapsedTime_2,
			&i.MovingTime_2,
			&i.StartDate_2,
			&i.StartDateLocal_2,
			&i.Distance_2,
			&i.StartIndex_2,
			&i.EndIndex_2,
			&i.DeviceWatts_2,
			&i.AverageWatts_2,
			&i.KomRank_2,
			&i.PrRank_2,
			&i.UpdatedAt_2,
			&i.ActivitiesID_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSegmentEffort = `-- name: UpsertSegmentEffort :one
INSERT INTO
	segment_efforts(
		updated_at,
		id, athlete_id, segment_id, name, elapsed_time,
		moving_time, start_date, start_date_local, distance,
		start_index, end_index, device_watts, average_watts,
		kom_rank, pr_rank, activities_id
	)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		athlete_id = $2,
		segment_id = $3,
		name = $4,
		elapsed_time = $5,
		moving_time = $6,
		start_date = $7,
		start_date_local = $8,
		distance = $9,
		start_index = $10,
		end_index = $11,
		device_watts = $12,
		average_watts = $13,
		kom_rank = $14,
		pr_rank = $15,
		activities_id = $16
	RETURNING id, athlete_id, segment_id, name, elapsed_time, moving_time, start_date, start_date_local, distance, start_index, end_index, device_watts, average_watts, kom_rank, pr_rank, updated_at, activities_id
`

type UpsertSegmentEffortParams struct {
	ID             int64         `db:"id" json:"id"`
	AthleteID      int64         `db:"athlete_id" json:"athlete_id"`
	SegmentID      int64         `db:"segment_id" json:"segment_id"`
	Name           string        `db:"name" json:"name"`
	ElapsedTime    float64       `db:"elapsed_time" json:"elapsed_time"`
	MovingTime     float64       `db:"moving_time" json:"moving_time"`
	StartDate      time.Time     `db:"start_date" json:"start_date"`
	StartDateLocal time.Time     `db:"start_date_local" json:"start_date_local"`
	Distance       float64       `db:"distance" json:"distance"`
	StartIndex     int32         `db:"start_index" json:"start_index"`
	EndIndex       int32         `db:"end_index" json:"end_index"`
	DeviceWatts    bool          `db:"device_watts" json:"device_watts"`
	AverageWatts   float64       `db:"average_watts" json:"average_watts"`
	KomRank        sql.NullInt32 `db:"kom_rank" json:"kom_rank"`
	PrRank         sql.NullInt32 `db:"pr_rank" json:"pr_rank"`
	ActivitiesID   int64         `db:"activities_id" json:"activities_id"`
}

func (q *sqlQuerier) UpsertSegmentEffort(ctx context.Context, arg UpsertSegmentEffortParams) (SegmentEffort, error) {
	row := q.db.QueryRowContext(ctx, upsertSegmentEffort,
		arg.ID,
		arg.AthleteID,
		arg.SegmentID,
		arg.Name,
		arg.ElapsedTime,
		arg.MovingTime,
		arg.StartDate,
		arg.StartDateLocal,
		arg.Distance,
		arg.StartIndex,
		arg.EndIndex,
		arg.DeviceWatts,
		arg.AverageWatts,
		arg.KomRank,
		arg.PrRank,
		arg.ActivitiesID,
	)
	var i SegmentEffort
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.SegmentID,
		&i.Name,
		&i.ElapsedTime,
		&i.MovingTime,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Distance,
		&i.StartIndex,
		&i.EndIndex,
		&i.DeviceWatts,
		&i.AverageWatts,
		&i.KomRank,
		&i.PrRank,
		&i.UpdatedAt,
		&i.ActivitiesID,
	)
	return i, err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM api_tokens
WHERE
	id = $1
`

func (q *sqlQuerier) DeleteToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteToken, id)
	return err
}

const getToken = `-- name: GetToken :one
SELECT
	id, name, athlete_id, hashed_token, created_at, updated_at, last_used_at, expires_at, lifetime_seconds
FROM
    api_tokens
WHERE
	id = $1
`

func (q *sqlQuerier) GetToken(ctx context.Context, id uuid.UUID) (ApiToken, error) {
	row := q.db.QueryRowContext(ctx, getToken, id)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AthleteID,
		&i.HashedToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.LifetimeSeconds,
	)
	return i, err
}

const insertAPIToken = `-- name: InsertAPIToken :one
INSERT INTO
    api_tokens (
		created_at,
		updated_at,
		last_used_at,
		id,
		name,
		athlete_id,
		hashed_token,
		expires_at,
		lifetime_seconds
	)
VALUES (Now(), Now(), Now(), $1, $2, $3, $4, $5, $6)
RETURNING id, name, athlete_id, hashed_token, created_at, updated_at, last_used_at, expires_at, lifetime_seconds
`

type InsertAPITokenParams struct {
	ID              uuid.UUID `db:"id" json:"id"`
	Name            string    `db:"name" json:"name"`
	AthleteID       int64     `db:"athlete_id" json:"athlete_id"`
	HashedToken     string    `db:"hashed_token" json:"hashed_token"`
	ExpiresAt       time.Time `db:"expires_at" json:"expires_at"`
	LifetimeSeconds int64     `db:"lifetime_seconds" json:"lifetime_seconds"`
}

func (q *sqlQuerier) InsertAPIToken(ctx context.Context, arg InsertAPITokenParams) (ApiToken, error) {
	row := q.db.QueryRowContext(ctx, insertAPIToken,
		arg.ID,
		arg.Name,
		arg.AthleteID,
		arg.HashedToken,
		arg.ExpiresAt,
		arg.LifetimeSeconds,
	)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AthleteID,
		&i.HashedToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.LifetimeSeconds,
	)
	return i, err
}

const renewToken = `-- name: RenewToken :one
UPDATE api_tokens
SET
	updated_at = Now(),
	last_used_at = Now(),
	expires_at = $1,
	lifetime_seconds = $2
WHERE
    id = $3
RETURNING id, name, athlete_id, hashed_token, created_at, updated_at, last_used_at, expires_at, lifetime_seconds
`

type RenewTokenParams struct {
	ExpiresAt       time.Time `db:"expires_at" json:"expires_at"`
	LifetimeSeconds int64     `db:"lifetime_seconds" json:"lifetime_seconds"`
	ID              uuid.UUID `db:"id" json:"id"`
}

func (q *sqlQuerier) RenewToken(ctx context.Context, arg RenewTokenParams) (ApiToken, error) {
	row := q.db.QueryRowContext(ctx, renewToken, arg.ExpiresAt, arg.LifetimeSeconds, arg.ID)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AthleteID,
		&i.HashedToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.LifetimeSeconds,
	)
	return i, err
}

const insertWebhookDump = `-- name: InsertWebhookDump :one
INSERT INTO
	webhook_dump(
	id, recorded_at, raw
)
VALUES
	(gen_random_uuid(), Now(), $1)
RETURNING id, recorded_at, raw
`

func (q *sqlQuerier) InsertWebhookDump(ctx context.Context, rawJson string) (WebhookDump, error) {
	row := q.db.QueryRowContext(ctx, insertWebhookDump, rawJson)
	var i WebhookDump
	err := row.Scan(&i.ID, &i.RecordedAt, &i.Raw)
	return i, err
}
