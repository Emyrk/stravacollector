// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const deleteActivity = `-- name: DeleteActivity :one
DELETE FROM
	activity_summary
WHERE
	id = $1
RETURNING id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate, download_count
`

func (q *sqlQuerier) DeleteActivity(ctx context.Context, id int64) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, deleteActivity, id)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.DownloadCount,
	)
	return i, err
}

const getActivityDetail = `-- name: GetActivityDetail :one
SELECT
	id, athlete_id, start_latlng, end_latlng, from_accepted_tag, average_cadence, average_temp, average_watts, weighted_average_watts, kilojoules, max_watts, elev_high, elev_low, suffer_score, calories, embed_token, segment_leaderboard_opt_out, leaderboard_opt_out, num_segment_efforts, premium_fetch, updated_at, map_id, source
FROM
	activity_detail
WHERE
	id = $1
`

func (q *sqlQuerier) GetActivityDetail(ctx context.Context, id int64) (ActivityDetail, error) {
	row := q.db.QueryRowContext(ctx, getActivityDetail, id)
	var i ActivityDetail
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		pq.Array(&i.StartLatlng),
		pq.Array(&i.EndLatlng),
		&i.FromAcceptedTag,
		&i.AverageCadence,
		&i.AverageTemp,
		&i.AverageWatts,
		&i.WeightedAverageWatts,
		&i.Kilojoules,
		&i.MaxWatts,
		&i.ElevHigh,
		&i.ElevLow,
		&i.SufferScore,
		&i.Calories,
		&i.EmbedToken,
		&i.SegmentLeaderboardOptOut,
		&i.LeaderboardOptOut,
		&i.NumSegmentEfforts,
		&i.PremiumFetch,
		&i.UpdatedAt,
		&i.MapID,
		&i.Source,
	)
	return i, err
}

const getActivitySummary = `-- name: GetActivitySummary :one
SELECT
	id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate, download_count
FROM
    activity_summary
WHERE
    id = $1
`

func (q *sqlQuerier) GetActivitySummary(ctx context.Context, id int64) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, getActivitySummary, id)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.DownloadCount,
	)
	return i, err
}

const incrementActivitySummaryDownload = `-- name: IncrementActivitySummaryDownload :exec
UPDATE activity_summary
SET
	download_count = download_count + 1
WHERE
	id = $1
`

func (q *sqlQuerier) IncrementActivitySummaryDownload(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementActivitySummaryDownload, id)
	return err
}

const missingSegments = `-- name: MissingSegments :one
with diff_data as (
	select unnest(segments) as data
	from (SELECT segments FROM competitive_routes WHERE name = 'das-hugel') as hugel
	except
	select segment_id as data
	from segment_efforts WHERE activities_id = $1
)
select array_agg(data order by data) :: text[]  as diff
from diff_data
`

func (q *sqlQuerier) MissingSegments(ctx context.Context, activitiesID int64) ([]string, error) {
	row := q.db.QueryRowContext(ctx, missingSegments, activitiesID)
	var diff []string
	err := row.Scan(pq.Array(&diff))
	return diff, err
}

const needsARefresh = `-- name: NeedsARefresh :many
SELECT
	activity_detail.athlete_id AS athlete_id, activity_detail.id AS activity_id
FROM
	activity_detail
		LEFT JOIN
	activity_summary ON activity_detail.id = activity_summary.id
WHERE
	activity_detail.updated_at > Now() - '60 hours' ::interval
  AND activity_summary.sport_type = 'Ride'
  AND
	(SELECT count(*) FROM segment_efforts WHERE activities_id = activity_detail.id) = 0
`

type NeedsARefreshRow struct {
	AthleteID  int64 `db:"athlete_id" json:"athlete_id"`
	ActivityID int64 `db:"activity_id" json:"activity_id"`
}

func (q *sqlQuerier) NeedsARefresh(ctx context.Context) ([]NeedsARefreshRow, error) {
	rows, err := q.db.QueryContext(ctx, needsARefresh)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeedsARefreshRow
	for rows.Next() {
		var i NeedsARefreshRow
		if err := rows.Scan(&i.AthleteID, &i.ActivityID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalActivityDetailsCount = `-- name: TotalActivityDetailsCount :one
SELECT count(*) FROM activity_detail
`

func (q *sqlQuerier) TotalActivityDetailsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, totalActivityDetailsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const totalRideActivitySummariesCount = `-- name: TotalRideActivitySummariesCount :one
SELECT count(*) FROM activity_summary WHERE activity_type = 'Ride'
`

func (q *sqlQuerier) TotalRideActivitySummariesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, totalRideActivitySummariesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateActivityName = `-- name: UpdateActivityName :exec
UPDATE activity_summary
SET
    name = $2
WHERE
    id = $1
`

type UpdateActivityNameParams struct {
	ID   int64  `db:"id" json:"id"`
	Name string `db:"name" json:"name"`
}

func (q *sqlQuerier) UpdateActivityName(ctx context.Context, arg UpdateActivityNameParams) error {
	_, err := q.db.ExecContext(ctx, updateActivityName, arg.ID, arg.Name)
	return err
}

const updateActivityType = `-- name: UpdateActivityType :exec
UPDATE activity_summary
SET
	sport_type = $2,
	activity_type = $2
WHERE
	id = $1
`

type UpdateActivityTypeParams struct {
	ID   int64  `db:"id" json:"id"`
	Type string `db:"type" json:"type"`
}

func (q *sqlQuerier) UpdateActivityType(ctx context.Context, arg UpdateActivityTypeParams) error {
	_, err := q.db.ExecContext(ctx, updateActivityType, arg.ID, arg.Type)
	return err
}

const upsertActivityDetail = `-- name: UpsertActivityDetail :one
INSERT INTO
	activity_detail(
		updated_at, id, athlete_id, start_latlng,
		end_latlng, from_accepted_tag, average_cadence, average_temp,
		average_watts, weighted_average_watts, kilojoules, max_watts,
	    elev_high, elev_low, suffer_score, embed_token,
	    segment_leaderboard_opt_out, leaderboard_opt_out, num_segment_efforts,
	    premium_fetch, map_id, calories, source
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
	 $18, $19, $20, $21, $22)
ON CONFLICT
	(id)
	DO UPDATE SET
	updated_at = Now(),
	athlete_id = $2,
	start_latlng = $3,
	end_latlng = $4,
	from_accepted_tag = $5,
	average_cadence = $6,
	average_temp = $7,
	average_watts = $8,
	weighted_average_watts = $9,
	kilojoules = $10,
	max_watts = $11,
	elev_high = $12,
	elev_low = $13,
	suffer_score = $14,
	embed_token = $15,
	segment_leaderboard_opt_out = $16,
	leaderboard_opt_out = $17,
	num_segment_efforts = $18,
	premium_fetch = $19,
	map_id = $20,
	calories = $21,
	source = $22
RETURNING id, athlete_id, start_latlng, end_latlng, from_accepted_tag, average_cadence, average_temp, average_watts, weighted_average_watts, kilojoules, max_watts, elev_high, elev_low, suffer_score, calories, embed_token, segment_leaderboard_opt_out, leaderboard_opt_out, num_segment_efforts, premium_fetch, updated_at, map_id, source
`

type UpsertActivityDetailParams struct {
	ID                       int64                `db:"id" json:"id"`
	AthleteID                int64                `db:"athlete_id" json:"athlete_id"`
	StartLatlng              []float64            `db:"start_latlng" json:"start_latlng"`
	EndLatlng                []float64            `db:"end_latlng" json:"end_latlng"`
	FromAcceptedTag          bool                 `db:"from_accepted_tag" json:"from_accepted_tag"`
	AverageCadence           float64              `db:"average_cadence" json:"average_cadence"`
	AverageTemp              float64              `db:"average_temp" json:"average_temp"`
	AverageWatts             float64              `db:"average_watts" json:"average_watts"`
	WeightedAverageWatts     float64              `db:"weighted_average_watts" json:"weighted_average_watts"`
	Kilojoules               float64              `db:"kilojoules" json:"kilojoules"`
	MaxWatts                 float64              `db:"max_watts" json:"max_watts"`
	ElevHigh                 float64              `db:"elev_high" json:"elev_high"`
	ElevLow                  float64              `db:"elev_low" json:"elev_low"`
	SufferScore              int32                `db:"suffer_score" json:"suffer_score"`
	EmbedToken               string               `db:"embed_token" json:"embed_token"`
	SegmentLeaderboardOptOut bool                 `db:"segment_leaderboard_opt_out" json:"segment_leaderboard_opt_out"`
	LeaderboardOptOut        bool                 `db:"leaderboard_opt_out" json:"leaderboard_opt_out"`
	NumSegmentEfforts        int32                `db:"num_segment_efforts" json:"num_segment_efforts"`
	PremiumFetch             bool                 `db:"premium_fetch" json:"premium_fetch"`
	MapID                    string               `db:"map_id" json:"map_id"`
	Calories                 float64              `db:"calories" json:"calories"`
	Source                   ActivityDetailSource `db:"source" json:"source"`
}

func (q *sqlQuerier) UpsertActivityDetail(ctx context.Context, arg UpsertActivityDetailParams) (ActivityDetail, error) {
	row := q.db.QueryRowContext(ctx, upsertActivityDetail,
		arg.ID,
		arg.AthleteID,
		pq.Array(arg.StartLatlng),
		pq.Array(arg.EndLatlng),
		arg.FromAcceptedTag,
		arg.AverageCadence,
		arg.AverageTemp,
		arg.AverageWatts,
		arg.WeightedAverageWatts,
		arg.Kilojoules,
		arg.MaxWatts,
		arg.ElevHigh,
		arg.ElevLow,
		arg.SufferScore,
		arg.EmbedToken,
		arg.SegmentLeaderboardOptOut,
		arg.LeaderboardOptOut,
		arg.NumSegmentEfforts,
		arg.PremiumFetch,
		arg.MapID,
		arg.Calories,
		arg.Source,
	)
	var i ActivityDetail
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		pq.Array(&i.StartLatlng),
		pq.Array(&i.EndLatlng),
		&i.FromAcceptedTag,
		&i.AverageCadence,
		&i.AverageTemp,
		&i.AverageWatts,
		&i.WeightedAverageWatts,
		&i.Kilojoules,
		&i.MaxWatts,
		&i.ElevHigh,
		&i.ElevLow,
		&i.SufferScore,
		&i.Calories,
		&i.EmbedToken,
		&i.SegmentLeaderboardOptOut,
		&i.LeaderboardOptOut,
		&i.NumSegmentEfforts,
		&i.PremiumFetch,
		&i.UpdatedAt,
		&i.MapID,
		&i.Source,
	)
	return i, err
}

const upsertActivitySummary = `-- name: UpsertActivitySummary :one
INSERT INTO
	activity_summary(
		updated_at, id, athlete_id, upload_id, external_id, name,
	    distance, moving_time, elapsed_time, total_elevation_gain,
	    activity_type, sport_type, workout_type, start_date,
	    start_date_local, timezone, utc_offset, achievement_count,
	    kudos_count, comment_count, athlete_count, photo_count, map_id,
	    trainer, commute, manual, private, flagged, gear_id, average_speed,
	    max_speed, device_watts, has_heartrate, pr_count, total_photo_count,
	    average_heartrate, max_heartrate
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
	 $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		athlete_id = $2,
		upload_id = $3,
		external_id = $4,
		name = $5,
		distance = $6,
		moving_time = $7,
		elapsed_time = $8,
		total_elevation_gain = $9,
		activity_type = $10,
		sport_type = $11,
		workout_type = $12,
		start_date = $13,
		start_date_local = $14,
		timezone = $15,
		utc_offset = $16,
		achievement_count = $17,
		kudos_count = $18,
		comment_count = $19,
		athlete_count = $20,
		photo_count = $21,
		map_id = $22,
		trainer = $23,
		commute = $24,
		manual = $25,
		private = $26,
		flagged = $27,
		gear_id = $28,
		average_speed = $29,
		max_speed = $30,
		device_watts = $31,
		has_heartrate = $32,
		pr_count = $33,
		total_photo_count = $34,
		average_heartrate = $35,
		max_heartrate = $36
RETURNING id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate, download_count
`

type UpsertActivitySummaryParams struct {
	ID                 int64     `db:"id" json:"id"`
	AthleteID          int64     `db:"athlete_id" json:"athlete_id"`
	UploadID           int64     `db:"upload_id" json:"upload_id"`
	ExternalID         string    `db:"external_id" json:"external_id"`
	Name               string    `db:"name" json:"name"`
	Distance           float64   `db:"distance" json:"distance"`
	MovingTime         float64   `db:"moving_time" json:"moving_time"`
	ElapsedTime        float64   `db:"elapsed_time" json:"elapsed_time"`
	TotalElevationGain float64   `db:"total_elevation_gain" json:"total_elevation_gain"`
	ActivityType       string    `db:"activity_type" json:"activity_type"`
	SportType          string    `db:"sport_type" json:"sport_type"`
	WorkoutType        int32     `db:"workout_type" json:"workout_type"`
	StartDate          time.Time `db:"start_date" json:"start_date"`
	StartDateLocal     time.Time `db:"start_date_local" json:"start_date_local"`
	Timezone           string    `db:"timezone" json:"timezone"`
	UtcOffset          float64   `db:"utc_offset" json:"utc_offset"`
	AchievementCount   int32     `db:"achievement_count" json:"achievement_count"`
	KudosCount         int32     `db:"kudos_count" json:"kudos_count"`
	CommentCount       int32     `db:"comment_count" json:"comment_count"`
	AthleteCount       int32     `db:"athlete_count" json:"athlete_count"`
	PhotoCount         int32     `db:"photo_count" json:"photo_count"`
	MapID              string    `db:"map_id" json:"map_id"`
	Trainer            bool      `db:"trainer" json:"trainer"`
	Commute            bool      `db:"commute" json:"commute"`
	Manual             bool      `db:"manual" json:"manual"`
	Private            bool      `db:"private" json:"private"`
	Flagged            bool      `db:"flagged" json:"flagged"`
	GearID             string    `db:"gear_id" json:"gear_id"`
	AverageSpeed       float64   `db:"average_speed" json:"average_speed"`
	MaxSpeed           float64   `db:"max_speed" json:"max_speed"`
	DeviceWatts        bool      `db:"device_watts" json:"device_watts"`
	HasHeartrate       bool      `db:"has_heartrate" json:"has_heartrate"`
	PrCount            int32     `db:"pr_count" json:"pr_count"`
	TotalPhotoCount    int32     `db:"total_photo_count" json:"total_photo_count"`
	AverageHeartrate   float64   `db:"average_heartrate" json:"average_heartrate"`
	MaxHeartrate       float64   `db:"max_heartrate" json:"max_heartrate"`
}

func (q *sqlQuerier) UpsertActivitySummary(ctx context.Context, arg UpsertActivitySummaryParams) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, upsertActivitySummary,
		arg.ID,
		arg.AthleteID,
		arg.UploadID,
		arg.ExternalID,
		arg.Name,
		arg.Distance,
		arg.MovingTime,
		arg.ElapsedTime,
		arg.TotalElevationGain,
		arg.ActivityType,
		arg.SportType,
		arg.WorkoutType,
		arg.StartDate,
		arg.StartDateLocal,
		arg.Timezone,
		arg.UtcOffset,
		arg.AchievementCount,
		arg.KudosCount,
		arg.CommentCount,
		arg.AthleteCount,
		arg.PhotoCount,
		arg.MapID,
		arg.Trainer,
		arg.Commute,
		arg.Manual,
		arg.Private,
		arg.Flagged,
		arg.GearID,
		arg.AverageSpeed,
		arg.MaxSpeed,
		arg.DeviceWatts,
		arg.HasHeartrate,
		arg.PrCount,
		arg.TotalPhotoCount,
		arg.AverageHeartrate,
		arg.MaxHeartrate,
	)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.DownloadCount,
	)
	return i, err
}

const athleteSyncedActivities = `-- name: AthleteSyncedActivities :many
SELECT
	activity_summary.id, activity_summary.athlete_id, activity_summary.upload_id, activity_summary.external_id, activity_summary.name, activity_summary.distance, activity_summary.moving_time, activity_summary.elapsed_time, activity_summary.total_elevation_gain, activity_summary.activity_type, activity_summary.sport_type, activity_summary.workout_type, activity_summary.start_date, activity_summary.start_date_local, activity_summary.timezone, activity_summary.utc_offset, activity_summary.achievement_count, activity_summary.kudos_count, activity_summary.comment_count, activity_summary.athlete_count, activity_summary.photo_count, activity_summary.map_id, activity_summary.trainer, activity_summary.commute, activity_summary.manual, activity_summary.private, activity_summary.flagged, activity_summary.gear_id, activity_summary.average_speed, activity_summary.max_speed, activity_summary.device_watts, activity_summary.has_heartrate, activity_summary.pr_count, activity_summary.total_photo_count, activity_summary.updated_at, activity_summary.average_heartrate, activity_summary.max_heartrate, activity_summary.download_count,
	COUNT(*) OVER() AS total,
	activity_detail.id IS NOT NULL :: boolean AS detail_exists,
	activity_detail.updated_at AS detail_updated_at
FROM
	activity_summary
LEFT JOIN
	activity_detail ON
		activity_summary.id = activity_detail.id
WHERE
	activity_summary.athlete_id = $1 AND
	LOWER(activity_summary.activity_type) = 'ride'
ORDER BY
    activity_summary.start_date DESC
LIMIT $3
OFFSET $2
`

type AthleteSyncedActivitiesParams struct {
	AthleteID int64 `db:"athlete_id" json:"athlete_id"`
	Offset    int32 `db:"_offset" json:"_offset"`
	Limit     int32 `db:"_limit" json:"_limit"`
}

type AthleteSyncedActivitiesRow struct {
	ActivitySummary ActivitySummary `db:"activity_summary" json:"activity_summary"`
	Total           int64           `db:"total" json:"total"`
	DetailExists    bool            `db:"detail_exists" json:"detail_exists"`
	DetailUpdatedAt sql.NullTime    `db:"detail_updated_at" json:"detail_updated_at"`
}

func (q *sqlQuerier) AthleteSyncedActivities(ctx context.Context, arg AthleteSyncedActivitiesParams) ([]AthleteSyncedActivitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, athleteSyncedActivities, arg.AthleteID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AthleteSyncedActivitiesRow
	for rows.Next() {
		var i AthleteSyncedActivitiesRow
		if err := rows.Scan(
			&i.ActivitySummary.ID,
			&i.ActivitySummary.AthleteID,
			&i.ActivitySummary.UploadID,
			&i.ActivitySummary.ExternalID,
			&i.ActivitySummary.Name,
			&i.ActivitySummary.Distance,
			&i.ActivitySummary.MovingTime,
			&i.ActivitySummary.ElapsedTime,
			&i.ActivitySummary.TotalElevationGain,
			&i.ActivitySummary.ActivityType,
			&i.ActivitySummary.SportType,
			&i.ActivitySummary.WorkoutType,
			&i.ActivitySummary.StartDate,
			&i.ActivitySummary.StartDateLocal,
			&i.ActivitySummary.Timezone,
			&i.ActivitySummary.UtcOffset,
			&i.ActivitySummary.AchievementCount,
			&i.ActivitySummary.KudosCount,
			&i.ActivitySummary.CommentCount,
			&i.ActivitySummary.AthleteCount,
			&i.ActivitySummary.PhotoCount,
			&i.ActivitySummary.MapID,
			&i.ActivitySummary.Trainer,
			&i.ActivitySummary.Commute,
			&i.ActivitySummary.Manual,
			&i.ActivitySummary.Private,
			&i.ActivitySummary.Flagged,
			&i.ActivitySummary.GearID,
			&i.ActivitySummary.AverageSpeed,
			&i.ActivitySummary.MaxSpeed,
			&i.ActivitySummary.DeviceWatts,
			&i.ActivitySummary.HasHeartrate,
			&i.ActivitySummary.PrCount,
			&i.ActivitySummary.TotalPhotoCount,
			&i.ActivitySummary.UpdatedAt,
			&i.ActivitySummary.AverageHeartrate,
			&i.ActivitySummary.MaxHeartrate,
			&i.ActivitySummary.DownloadCount,
			&i.Total,
			&i.DetailExists,
			&i.DetailUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteAthleteLogin = `-- name: DeleteAthleteLogin :exec
DELETE FROM athlete_logins WHERE athlete_id = $1
`

func (q *sqlQuerier) DeleteAthleteLogin(ctx context.Context, athleteID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAthleteLogin, athleteID)
	return err
}

const getAthlete = `-- name: GetAthlete :one
SELECT id, summit, username, firstname, lastname, sex, city, state, country, follow_count, friend_count, measurement_preference, ftp, weight, clubs, created_at, updated_at, fetched_at, profile_pic_link, profile_pic_link_medium FROM athletes WHERE id = $1
`

func (q *sqlQuerier) GetAthlete(ctx context.Context, athleteID int64) (Athlete, error) {
	row := q.db.QueryRowContext(ctx, getAthlete, athleteID)
	var i Athlete
	err := row.Scan(
		&i.ID,
		&i.Summit,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Sex,
		&i.City,
		&i.State,
		&i.Country,
		&i.FollowCount,
		&i.FriendCount,
		&i.MeasurementPreference,
		&i.Ftp,
		&i.Weight,
		&i.Clubs,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FetchedAt,
		&i.ProfilePicLink,
		&i.ProfilePicLinkMedium,
	)
	return i, err
}

const getAthleteFull = `-- name: GetAthleteFull :one
SELECT
	athletes.id, athletes.summit, athletes.username, athletes.firstname, athletes.lastname, athletes.sex, athletes.city, athletes.state, athletes.country, athletes.follow_count, athletes.friend_count, athletes.measurement_preference, athletes.ftp, athletes.weight, athletes.clubs, athletes.created_at, athletes.updated_at, athletes.fetched_at, athletes.profile_pic_link, athletes.profile_pic_link_medium,
	COALESCE(athlete_hugel_count.count, 0) AS hugel_count
FROM
	athletes
	LEFT JOIN
	athlete_hugel_count ON athlete_hugel_count.athlete_id = athletes.id
WHERE
	athletes.id = $1
`

type GetAthleteFullRow struct {
	Athlete    Athlete `db:"athlete" json:"athlete"`
	HugelCount int64   `db:"hugel_count" json:"hugel_count"`
}

func (q *sqlQuerier) GetAthleteFull(ctx context.Context, athleteID int64) (GetAthleteFullRow, error) {
	row := q.db.QueryRowContext(ctx, getAthleteFull, athleteID)
	var i GetAthleteFullRow
	err := row.Scan(
		&i.Athlete.ID,
		&i.Athlete.Summit,
		&i.Athlete.Username,
		&i.Athlete.Firstname,
		&i.Athlete.Lastname,
		&i.Athlete.Sex,
		&i.Athlete.City,
		&i.Athlete.State,
		&i.Athlete.Country,
		&i.Athlete.FollowCount,
		&i.Athlete.FriendCount,
		&i.Athlete.MeasurementPreference,
		&i.Athlete.Ftp,
		&i.Athlete.Weight,
		&i.Athlete.Clubs,
		&i.Athlete.CreatedAt,
		&i.Athlete.UpdatedAt,
		&i.Athlete.FetchedAt,
		&i.Athlete.ProfilePicLink,
		&i.Athlete.ProfilePicLinkMedium,
		&i.HugelCount,
	)
	return i, err
}

const getAthleteLoad = `-- name: GetAthleteLoad :one
SELECT athlete_id, last_backload_activity_start, last_load_attempt, last_load_incomplete, last_load_error, activites_loaded_last_attempt, earliest_activity, earliest_activity_done, earliest_activity_id, next_load_not_before FROM athlete_load WHERE athlete_id = $1
`

func (q *sqlQuerier) GetAthleteLoad(ctx context.Context, athleteID int64) (AthleteLoad, error) {
	row := q.db.QueryRowContext(ctx, getAthleteLoad, athleteID)
	var i AthleteLoad
	err := row.Scan(
		&i.AthleteID,
		&i.LastBackloadActivityStart,
		&i.LastLoadAttempt,
		&i.LastLoadIncomplete,
		&i.LastLoadError,
		&i.ActivitesLoadedLastAttempt,
		&i.EarliestActivity,
		&i.EarliestActivityDone,
		&i.EarliestActivityID,
		&i.NextLoadNotBefore,
	)
	return i, err
}

const getAthleteLoadDetailed = `-- name: GetAthleteLoadDetailed :one
SELECT
    athlete_load.athlete_id, athlete_load.last_backload_activity_start, athlete_load.last_load_attempt, athlete_load.last_load_incomplete, athlete_load.last_load_error, athlete_load.activites_loaded_last_attempt, athlete_load.earliest_activity, athlete_load.earliest_activity_done, athlete_load.earliest_activity_id, athlete_load.next_load_not_before,
    athletes.id, athletes.summit, athletes.username, athletes.firstname, athletes.lastname, athletes.sex, athletes.city, athletes.state, athletes.country, athletes.follow_count, athletes.friend_count, athletes.measurement_preference, athletes.ftp, athletes.weight, athletes.clubs, athletes.created_at, athletes.updated_at, athletes.fetched_at, athletes.profile_pic_link, athletes.profile_pic_link_medium,
	(SELECT count(*) FROM activity_summary WHERE activity_summary.athlete_id = $1 AND LOWER(activity_summary.activity_type) = 'ride') AS summary_count,
    (SELECT count(*) FROM activity_detail WHERE activity_detail.athlete_id = $1 AND activity_detail.id = ANY(
		SELECT id FROM activity_summary WHERE activity_summary.athlete_id = $1 AND LOWER(activity_summary.activity_type) = 'ride')
	) AS detail_count,
	COALESCE(athlete_hugel_count.count, 0) AS hugel_count
FROM
    athlete_load
INNER JOIN
    athletes ON athletes.id = athlete_load.athlete_id
LEFT JOIN
	athlete_hugel_count ON athlete_hugel_count.athlete_id = athletes.id
WHERE
		athlete_load.athlete_id = $1
`

type GetAthleteLoadDetailedRow struct {
	AthleteLoad  AthleteLoad `db:"athlete_load" json:"athlete_load"`
	Athlete      Athlete     `db:"athlete" json:"athlete"`
	SummaryCount int64       `db:"summary_count" json:"summary_count"`
	DetailCount  int64       `db:"detail_count" json:"detail_count"`
	HugelCount   int64       `db:"hugel_count" json:"hugel_count"`
}

func (q *sqlQuerier) GetAthleteLoadDetailed(ctx context.Context, athleteID int64) (GetAthleteLoadDetailedRow, error) {
	row := q.db.QueryRowContext(ctx, getAthleteLoadDetailed, athleteID)
	var i GetAthleteLoadDetailedRow
	err := row.Scan(
		&i.AthleteLoad.AthleteID,
		&i.AthleteLoad.LastBackloadActivityStart,
		&i.AthleteLoad.LastLoadAttempt,
		&i.AthleteLoad.LastLoadIncomplete,
		&i.AthleteLoad.LastLoadError,
		&i.AthleteLoad.ActivitesLoadedLastAttempt,
		&i.AthleteLoad.EarliestActivity,
		&i.AthleteLoad.EarliestActivityDone,
		&i.AthleteLoad.EarliestActivityID,
		&i.AthleteLoad.NextLoadNotBefore,
		&i.Athlete.ID,
		&i.Athlete.Summit,
		&i.Athlete.Username,
		&i.Athlete.Firstname,
		&i.Athlete.Lastname,
		&i.Athlete.Sex,
		&i.Athlete.City,
		&i.Athlete.State,
		&i.Athlete.Country,
		&i.Athlete.FollowCount,
		&i.Athlete.FriendCount,
		&i.Athlete.MeasurementPreference,
		&i.Athlete.Ftp,
		&i.Athlete.Weight,
		&i.Athlete.Clubs,
		&i.Athlete.CreatedAt,
		&i.Athlete.UpdatedAt,
		&i.Athlete.FetchedAt,
		&i.Athlete.ProfilePicLink,
		&i.Athlete.ProfilePicLinkMedium,
		&i.SummaryCount,
		&i.DetailCount,
		&i.HugelCount,
	)
	return i, err
}

const getAthleteLogin = `-- name: GetAthleteLogin :one
SELECT athlete_id, summit, provider_id, created_at, updated_at, oauth_access_token, oauth_refresh_token, oauth_expiry, oauth_token_type, id FROM athlete_logins WHERE athlete_id = $1
`

func (q *sqlQuerier) GetAthleteLogin(ctx context.Context, athleteID int64) (AthleteLogin, error) {
	row := q.db.QueryRowContext(ctx, getAthleteLogin, athleteID)
	var i AthleteLogin
	err := row.Scan(
		&i.AthleteID,
		&i.Summit,
		&i.ProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthAccessToken,
		&i.OauthRefreshToken,
		&i.OauthExpiry,
		&i.OauthTokenType,
		&i.ID,
	)
	return i, err
}

const getAthleteLoginFull = `-- name: GetAthleteLoginFull :one
SELECT
    athlete_logins.athlete_id, athlete_logins.summit, athlete_logins.provider_id, athlete_logins.created_at, athlete_logins.updated_at, athlete_logins.oauth_access_token, athlete_logins.oauth_refresh_token, athlete_logins.oauth_expiry, athlete_logins.oauth_token_type, athlete_logins.id,
    athletes.id, athletes.summit, athletes.username, athletes.firstname, athletes.lastname, athletes.sex, athletes.city, athletes.state, athletes.country, athletes.follow_count, athletes.friend_count, athletes.measurement_preference, athletes.ftp, athletes.weight, athletes.clubs, athletes.created_at, athletes.updated_at, athletes.fetched_at, athletes.profile_pic_link, athletes.profile_pic_link_medium,
    COALESCE(athlete_hugel_count.count, 0) AS hugel_count
FROM
    athlete_logins
INNER JOIN
    athletes ON athlete_logins.athlete_id = athletes.id
LEFT JOIN
	athlete_hugel_count ON athlete_hugel_count.athlete_id = athletes.id
WHERE
	athlete_logins.athlete_id = $1
`

type GetAthleteLoginFullRow struct {
	AthleteLogin AthleteLogin `db:"athlete_login" json:"athlete_login"`
	Athlete      Athlete      `db:"athlete" json:"athlete"`
	HugelCount   int64        `db:"hugel_count" json:"hugel_count"`
}

func (q *sqlQuerier) GetAthleteLoginFull(ctx context.Context, athleteID int64) (GetAthleteLoginFullRow, error) {
	row := q.db.QueryRowContext(ctx, getAthleteLoginFull, athleteID)
	var i GetAthleteLoginFullRow
	err := row.Scan(
		&i.AthleteLogin.AthleteID,
		&i.AthleteLogin.Summit,
		&i.AthleteLogin.ProviderID,
		&i.AthleteLogin.CreatedAt,
		&i.AthleteLogin.UpdatedAt,
		&i.AthleteLogin.OauthAccessToken,
		&i.AthleteLogin.OauthRefreshToken,
		&i.AthleteLogin.OauthExpiry,
		&i.AthleteLogin.OauthTokenType,
		&i.AthleteLogin.ID,
		&i.Athlete.ID,
		&i.Athlete.Summit,
		&i.Athlete.Username,
		&i.Athlete.Firstname,
		&i.Athlete.Lastname,
		&i.Athlete.Sex,
		&i.Athlete.City,
		&i.Athlete.State,
		&i.Athlete.Country,
		&i.Athlete.FollowCount,
		&i.Athlete.FriendCount,
		&i.Athlete.MeasurementPreference,
		&i.Athlete.Ftp,
		&i.Athlete.Weight,
		&i.Athlete.Clubs,
		&i.Athlete.CreatedAt,
		&i.Athlete.UpdatedAt,
		&i.Athlete.FetchedAt,
		&i.Athlete.ProfilePicLink,
		&i.Athlete.ProfilePicLinkMedium,
		&i.HugelCount,
	)
	return i, err
}

const getAthleteNeedsLoad = `-- name: GetAthleteNeedsLoad :many
SELECT
    athlete_load.athlete_id, athlete_load.last_backload_activity_start, athlete_load.last_load_attempt, athlete_load.last_load_incomplete, athlete_load.last_load_error, athlete_load.activites_loaded_last_attempt, athlete_load.earliest_activity, athlete_load.earliest_activity_done, athlete_load.earliest_activity_id, athlete_load.next_load_not_before, athlete_logins.athlete_id, athlete_logins.summit, athlete_logins.provider_id, athlete_logins.created_at, athlete_logins.updated_at, athlete_logins.oauth_access_token, athlete_logins.oauth_refresh_token, athlete_logins.oauth_expiry, athlete_logins.oauth_token_type, athlete_logins.id
FROM
	athlete_load
INNER JOIN
	athlete_logins
ON
    athlete_load.athlete_id = athlete_logins.athlete_id
WHERE
    athlete_load.next_load_not_before < Now()
ORDER BY
	-- Athletes with oldest load attempt first.
	-- Order is [false, true]. 
	not last_load_incomplete, earliest_activity_done, last_load_attempt
LIMIT 5
`

type GetAthleteNeedsLoadRow struct {
	AthleteLoad  AthleteLoad  `db:"athlete_load" json:"athlete_load"`
	AthleteLogin AthleteLogin `db:"athlete_login" json:"athlete_login"`
}

func (q *sqlQuerier) GetAthleteNeedsLoad(ctx context.Context) ([]GetAthleteNeedsLoadRow, error) {
	rows, err := q.db.QueryContext(ctx, getAthleteNeedsLoad)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAthleteNeedsLoadRow
	for rows.Next() {
		var i GetAthleteNeedsLoadRow
		if err := rows.Scan(
			&i.AthleteLoad.AthleteID,
			&i.AthleteLoad.LastBackloadActivityStart,
			&i.AthleteLoad.LastLoadAttempt,
			&i.AthleteLoad.LastLoadIncomplete,
			&i.AthleteLoad.LastLoadError,
			&i.AthleteLoad.ActivitesLoadedLastAttempt,
			&i.AthleteLoad.EarliestActivity,
			&i.AthleteLoad.EarliestActivityDone,
			&i.AthleteLoad.EarliestActivityID,
			&i.AthleteLoad.NextLoadNotBefore,
			&i.AthleteLogin.AthleteID,
			&i.AthleteLogin.Summit,
			&i.AthleteLogin.ProviderID,
			&i.AthleteLogin.CreatedAt,
			&i.AthleteLogin.UpdatedAt,
			&i.AthleteLogin.OauthAccessToken,
			&i.AthleteLogin.OauthRefreshToken,
			&i.AthleteLogin.OauthExpiry,
			&i.AthleteLogin.OauthTokenType,
			&i.AthleteLogin.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAthlete = `-- name: UpsertAthlete :one
INSERT INTO
	athletes(
	fetched_at, id, created_at, updated_at,
		summit, username, firstname, lastname, sex, city, state, country,
		follow_count, friend_count, measurement_preference, ftp, weight, clubs,
		profile_pic_link, profile_pic_link_medium
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
ON CONFLICT
	(id)
	DO UPDATE SET
		fetched_at = Now(),
		created_at = $2,
		updated_at = $3,
		summit = $4,
		username = $5,
		firstname = $6,
		lastname = $7,
		sex = $8,
		city = $9,
		state = $10,
		country = $11,
		follow_count = $12,
		friend_count = $13,
		measurement_preference = $14,
		ftp = $15,
		weight = $16,
		clubs = $17,
		profile_pic_link = $18,
		profile_pic_link_medium = $19
RETURNING id, summit, username, firstname, lastname, sex, city, state, country, follow_count, friend_count, measurement_preference, ftp, weight, clubs, created_at, updated_at, fetched_at, profile_pic_link, profile_pic_link_medium
`

type UpsertAthleteParams struct {
	ID                    int64           `db:"id" json:"id"`
	CreatedAt             time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt             time.Time       `db:"updated_at" json:"updated_at"`
	Summit                bool            `db:"summit" json:"summit"`
	Username              string          `db:"username" json:"username"`
	Firstname             string          `db:"firstname" json:"firstname"`
	Lastname              string          `db:"lastname" json:"lastname"`
	Sex                   string          `db:"sex" json:"sex"`
	City                  string          `db:"city" json:"city"`
	State                 string          `db:"state" json:"state"`
	Country               string          `db:"country" json:"country"`
	FollowCount           int32           `db:"follow_count" json:"follow_count"`
	FriendCount           int32           `db:"friend_count" json:"friend_count"`
	MeasurementPreference string          `db:"measurement_preference" json:"measurement_preference"`
	Ftp                   float64         `db:"ftp" json:"ftp"`
	Weight                float64         `db:"weight" json:"weight"`
	Clubs                 json.RawMessage `db:"clubs" json:"clubs"`
	ProfilePicLink        string          `db:"profile_pic_link" json:"profile_pic_link"`
	ProfilePicLinkMedium  string          `db:"profile_pic_link_medium" json:"profile_pic_link_medium"`
}

func (q *sqlQuerier) UpsertAthlete(ctx context.Context, arg UpsertAthleteParams) (Athlete, error) {
	row := q.db.QueryRowContext(ctx, upsertAthlete,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Summit,
		arg.Username,
		arg.Firstname,
		arg.Lastname,
		arg.Sex,
		arg.City,
		arg.State,
		arg.Country,
		arg.FollowCount,
		arg.FriendCount,
		arg.MeasurementPreference,
		arg.Ftp,
		arg.Weight,
		arg.Clubs,
		arg.ProfilePicLink,
		arg.ProfilePicLinkMedium,
	)
	var i Athlete
	err := row.Scan(
		&i.ID,
		&i.Summit,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Sex,
		&i.City,
		&i.State,
		&i.Country,
		&i.FollowCount,
		&i.FriendCount,
		&i.MeasurementPreference,
		&i.Ftp,
		&i.Weight,
		&i.Clubs,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FetchedAt,
		&i.ProfilePicLink,
		&i.ProfilePicLinkMedium,
	)
	return i, err
}

const upsertAthleteLoad = `-- name: UpsertAthleteLoad :one
INSERT INTO
	athlete_load(
		athlete_id,
		last_backload_activity_start,
	    last_load_attempt,
		last_load_incomplete,
		last_load_error,
		activites_loaded_last_attempt,
		earliest_activity,
	    earliest_activity_id,
		earliest_activity_done,
		next_load_not_before
	)
VALUES
	($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT
	(athlete_id)
DO UPDATE SET
	last_backload_activity_start = $2,
	last_load_attempt = $3,
	last_load_incomplete = $4,
	last_load_error = $5,
	activites_loaded_last_attempt = $6,
	earliest_activity = $7,
	earliest_activity_id = $8,
	earliest_activity_done = $9,
    next_load_not_before = $10
RETURNING athlete_id, last_backload_activity_start, last_load_attempt, last_load_incomplete, last_load_error, activites_loaded_last_attempt, earliest_activity, earliest_activity_done, earliest_activity_id, next_load_not_before
`

type UpsertAthleteLoadParams struct {
	AthleteID                  int64     `db:"athlete_id" json:"athlete_id"`
	LastBackloadActivityStart  time.Time `db:"last_backload_activity_start" json:"last_backload_activity_start"`
	LastLoadAttempt            time.Time `db:"last_load_attempt" json:"last_load_attempt"`
	LastLoadIncomplete         bool      `db:"last_load_incomplete" json:"last_load_incomplete"`
	LastLoadError              string    `db:"last_load_error" json:"last_load_error"`
	ActivitesLoadedLastAttempt int32     `db:"activites_loaded_last_attempt" json:"activites_loaded_last_attempt"`
	EarliestActivity           time.Time `db:"earliest_activity" json:"earliest_activity"`
	EarliestActivityID         int64     `db:"earliest_activity_id" json:"earliest_activity_id"`
	EarliestActivityDone       bool      `db:"earliest_activity_done" json:"earliest_activity_done"`
	NextLoadNotBefore          time.Time `db:"next_load_not_before" json:"next_load_not_before"`
}

func (q *sqlQuerier) UpsertAthleteLoad(ctx context.Context, arg UpsertAthleteLoadParams) (AthleteLoad, error) {
	row := q.db.QueryRowContext(ctx, upsertAthleteLoad,
		arg.AthleteID,
		arg.LastBackloadActivityStart,
		arg.LastLoadAttempt,
		arg.LastLoadIncomplete,
		arg.LastLoadError,
		arg.ActivitesLoadedLastAttempt,
		arg.EarliestActivity,
		arg.EarliestActivityID,
		arg.EarliestActivityDone,
		arg.NextLoadNotBefore,
	)
	var i AthleteLoad
	err := row.Scan(
		&i.AthleteID,
		&i.LastBackloadActivityStart,
		&i.LastLoadAttempt,
		&i.LastLoadIncomplete,
		&i.LastLoadError,
		&i.ActivitesLoadedLastAttempt,
		&i.EarliestActivity,
		&i.EarliestActivityDone,
		&i.EarliestActivityID,
		&i.NextLoadNotBefore,
	)
	return i, err
}

const upsertAthleteLogin = `-- name: UpsertAthleteLogin :one
INSERT INTO
	athlete_logins(
		created_at, updated_at, id,
             athlete_id, summit, provider_id, oauth_access_token,
             oauth_refresh_token, oauth_expiry, oauth_token_type
	)
VALUES
    (Now(), Now(), gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7)
ON CONFLICT
	(athlete_id)
DO UPDATE SET
	updated_at = Now(),
	summit = $2,
	provider_id = $3,
	oauth_access_token = $4,
	oauth_refresh_token = $5,
	oauth_expiry = $6,
	oauth_token_type = $7
RETURNING athlete_id, summit, provider_id, created_at, updated_at, oauth_access_token, oauth_refresh_token, oauth_expiry, oauth_token_type, id
`

type UpsertAthleteLoginParams struct {
	AthleteID         int64     `db:"athlete_id" json:"athlete_id"`
	Summit            bool      `db:"summit" json:"summit"`
	ProviderID        string    `db:"provider_id" json:"provider_id"`
	OauthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OauthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OauthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
	OauthTokenType    string    `db:"oauth_token_type" json:"oauth_token_type"`
}

func (q *sqlQuerier) UpsertAthleteLogin(ctx context.Context, arg UpsertAthleteLoginParams) (AthleteLogin, error) {
	row := q.db.QueryRowContext(ctx, upsertAthleteLogin,
		arg.AthleteID,
		arg.Summit,
		arg.ProviderID,
		arg.OauthAccessToken,
		arg.OauthRefreshToken,
		arg.OauthExpiry,
		arg.OauthTokenType,
	)
	var i AthleteLogin
	err := row.Scan(
		&i.AthleteID,
		&i.Summit,
		&i.ProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthAccessToken,
		&i.OauthRefreshToken,
		&i.OauthExpiry,
		&i.OauthTokenType,
		&i.ID,
	)
	return i, err
}

const athleteHugelActivites = `-- name: AthleteHugelActivites :many
SELECT
    hugel_activities.activity_id, hugel_activities.athlete_id, hugel_activities.segment_ids, hugel_activities.total_time_seconds, hugel_activities.efforts,
    activity_summary.id, activity_summary.athlete_id, activity_summary.upload_id, activity_summary.external_id, activity_summary.name, activity_summary.distance, activity_summary.moving_time, activity_summary.elapsed_time, activity_summary.total_elevation_gain, activity_summary.activity_type, activity_summary.sport_type, activity_summary.workout_type, activity_summary.start_date, activity_summary.start_date_local, activity_summary.timezone, activity_summary.utc_offset, activity_summary.achievement_count, activity_summary.kudos_count, activity_summary.comment_count, activity_summary.athlete_count, activity_summary.photo_count, activity_summary.map_id, activity_summary.trainer, activity_summary.commute, activity_summary.manual, activity_summary.private, activity_summary.flagged, activity_summary.gear_id, activity_summary.average_speed, activity_summary.max_speed, activity_summary.device_watts, activity_summary.has_heartrate, activity_summary.pr_count, activity_summary.total_photo_count, activity_summary.updated_at, activity_summary.average_heartrate, activity_summary.max_heartrate, activity_summary.download_count
FROM
    hugel_activities
INNER JOIN
	activity_summary ON hugel_activities.activity_id = activity_summary.id
WHERE
	hugel_activities.athlete_id = $1
`

type AthleteHugelActivitesRow struct {
	HugelActivity   HugelActivity   `db:"hugel_activity" json:"hugel_activity"`
	ActivitySummary ActivitySummary `db:"activity_summary" json:"activity_summary"`
}

func (q *sqlQuerier) AthleteHugelActivites(ctx context.Context, athleteID int64) ([]AthleteHugelActivitesRow, error) {
	rows, err := q.db.QueryContext(ctx, athleteHugelActivites, athleteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AthleteHugelActivitesRow
	for rows.Next() {
		var i AthleteHugelActivitesRow
		if err := rows.Scan(
			&i.HugelActivity.ActivityID,
			&i.HugelActivity.AthleteID,
			&i.HugelActivity.SegmentIds,
			&i.HugelActivity.TotalTimeSeconds,
			&i.HugelActivity.Efforts,
			&i.ActivitySummary.ID,
			&i.ActivitySummary.AthleteID,
			&i.ActivitySummary.UploadID,
			&i.ActivitySummary.ExternalID,
			&i.ActivitySummary.Name,
			&i.ActivitySummary.Distance,
			&i.ActivitySummary.MovingTime,
			&i.ActivitySummary.ElapsedTime,
			&i.ActivitySummary.TotalElevationGain,
			&i.ActivitySummary.ActivityType,
			&i.ActivitySummary.SportType,
			&i.ActivitySummary.WorkoutType,
			&i.ActivitySummary.StartDate,
			&i.ActivitySummary.StartDateLocal,
			&i.ActivitySummary.Timezone,
			&i.ActivitySummary.UtcOffset,
			&i.ActivitySummary.AchievementCount,
			&i.ActivitySummary.KudosCount,
			&i.ActivitySummary.CommentCount,
			&i.ActivitySummary.AthleteCount,
			&i.ActivitySummary.PhotoCount,
			&i.ActivitySummary.MapID,
			&i.ActivitySummary.Trainer,
			&i.ActivitySummary.Commute,
			&i.ActivitySummary.Manual,
			&i.ActivitySummary.Private,
			&i.ActivitySummary.Flagged,
			&i.ActivitySummary.GearID,
			&i.ActivitySummary.AverageSpeed,
			&i.ActivitySummary.MaxSpeed,
			&i.ActivitySummary.DeviceWatts,
			&i.ActivitySummary.HasHeartrate,
			&i.ActivitySummary.PrCount,
			&i.ActivitySummary.TotalPhotoCount,
			&i.ActivitySummary.UpdatedAt,
			&i.ActivitySummary.AverageHeartrate,
			&i.ActivitySummary.MaxHeartrate,
			&i.ActivitySummary.DownloadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompetitiveRoute = `-- name: GetCompetitiveRoute :one
SELECT
	competitive_routes.name, competitive_routes.display_name, competitive_routes.description, (
	SELECT
		json_agg(
			json_build_object(
				'id',segments.id,
				'name',segments.name
			)
		) AS segment_summaries
	FROM
		segments
	WHERE
		id = ANY(competitive_routes.segments)
)
FROM
	competitive_routes
WHERE
	competitive_routes.name = $1
LIMIT 1
`

type GetCompetitiveRouteRow struct {
	Name             string          `db:"name" json:"name"`
	DisplayName      string          `db:"display_name" json:"display_name"`
	Description      string          `db:"description" json:"description"`
	SegmentSummaries json.RawMessage `db:"segment_summaries" json:"segment_summaries"`
}

func (q *sqlQuerier) GetCompetitiveRoute(ctx context.Context, routeName string) (GetCompetitiveRouteRow, error) {
	row := q.db.QueryRowContext(ctx, getCompetitiveRoute, routeName)
	var i GetCompetitiveRouteRow
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.SegmentSummaries,
	)
	return i, err
}

const hugelLeaderboard = `-- name: HugelLeaderboard :many
SELECT
	(SELECT min(total_time_seconds) FROM hugel_activities) :: BIGINT AS best_time,
	ROW_NUMBER() over(ORDER BY total_time_seconds ASC) AS rank,
	athlete_bests.activity_id,
	athlete_bests.athlete_id,
	athlete_bests.total_time_seconds,
	athlete_bests.efforts,

	activity_summary.name,
	activity_summary.device_watts,
	activity_summary.distance,
	activity_summary.moving_time,
	activity_summary.elapsed_time,
	activity_summary.total_elevation_gain,
	activity_summary.start_date,
	activity_summary.achievement_count,
	activity_summary.average_heartrate,
	activity_summary.average_speed,

	activity_detail.suffer_score,
	activity_detail.average_watts,
	activity_detail.average_cadence,

	athletes.firstname,
	athletes.lastname,
	athletes.username,
	athletes.profile_pic_link,
	athletes.sex,
	COALESCE(hugel_count.count, 0) AS hugel_count
FROM
	(
		SELECT DISTINCT ON (athlete_id)
			activity_id, athlete_id, segment_ids, total_time_seconds, efforts
		FROM
			hugel_activities
		ORDER BY
			athlete_id, total_time_seconds ASC
	) AS athlete_bests
INNER JOIN
	athletes ON athlete_bests.athlete_id = athletes.id
LEFT JOIN athlete_hugel_count AS hugel_count
	ON hugel_count.athlete_id = athlete_bests.athlete_id
INNER JOIN
	activity_summary ON athlete_bests.activity_id = activity_summary.id
INNER JOIN
	activity_detail ON athlete_bests.activity_id = activity_detail.id
WHERE
    CASE WHEN $1 > 0 THEN athlete_bests.athlete_id = $1 ELSE TRUE END
    AND
	CASE WHEN
    	$2 :: timestamp != '0001-01-01 00:00:00Z'
    		AND $3 :: timestamp != '0001-01-01 00:00:00Z' THEN
			activity_summary.start_date >= $2 :: timestamp AND activity_summary.start_date <= $3 :: timestamp
    	ELSE TRUE END
	ORDER BY
		athlete_bests.total_time_seconds ASC
`

type HugelLeaderboardParams struct {
	AthleteID interface{} `db:"athlete_id" json:"athlete_id"`
	After     time.Time   `db:"after" json:"after"`
	Before    time.Time   `db:"before" json:"before"`
}

type HugelLeaderboardRow struct {
	BestTime           int64               `db:"best_time" json:"best_time"`
	Rank               int64               `db:"rank" json:"rank"`
	ActivityID         int64               `db:"activity_id" json:"activity_id"`
	AthleteID          int64               `db:"athlete_id" json:"athlete_id"`
	TotalTimeSeconds   int64               `db:"total_time_seconds" json:"total_time_seconds"`
	Efforts            HugelSegmentEfforts `db:"efforts" json:"efforts"`
	Name               string              `db:"name" json:"name"`
	DeviceWatts        bool                `db:"device_watts" json:"device_watts"`
	Distance           float64             `db:"distance" json:"distance"`
	MovingTime         float64             `db:"moving_time" json:"moving_time"`
	ElapsedTime        float64             `db:"elapsed_time" json:"elapsed_time"`
	TotalElevationGain float64             `db:"total_elevation_gain" json:"total_elevation_gain"`
	StartDate          time.Time           `db:"start_date" json:"start_date"`
	AchievementCount   int32               `db:"achievement_count" json:"achievement_count"`
	AverageHeartrate   float64             `db:"average_heartrate" json:"average_heartrate"`
	AverageSpeed       float64             `db:"average_speed" json:"average_speed"`
	SufferScore        int32               `db:"suffer_score" json:"suffer_score"`
	AverageWatts       float64             `db:"average_watts" json:"average_watts"`
	AverageCadence     float64             `db:"average_cadence" json:"average_cadence"`
	Firstname          string              `db:"firstname" json:"firstname"`
	Lastname           string              `db:"lastname" json:"lastname"`
	Username           string              `db:"username" json:"username"`
	ProfilePicLink     string              `db:"profile_pic_link" json:"profile_pic_link"`
	Sex                string              `db:"sex" json:"sex"`
	HugelCount         int64               `db:"hugel_count" json:"hugel_count"`
}

func (q *sqlQuerier) HugelLeaderboard(ctx context.Context, arg HugelLeaderboardParams) ([]HugelLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, hugelLeaderboard, arg.AthleteID, arg.After, arg.Before)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HugelLeaderboardRow
	for rows.Next() {
		var i HugelLeaderboardRow
		if err := rows.Scan(
			&i.BestTime,
			&i.Rank,
			&i.ActivityID,
			&i.AthleteID,
			&i.TotalTimeSeconds,
			&i.Efforts,
			&i.Name,
			&i.DeviceWatts,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.StartDate,
			&i.AchievementCount,
			&i.AverageHeartrate,
			&i.AverageSpeed,
			&i.SufferScore,
			&i.AverageWatts,
			&i.AverageCadence,
			&i.Firstname,
			&i.Lastname,
			&i.Username,
			&i.ProfilePicLink,
			&i.Sex,
			&i.HugelCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const missingHugelSegments = `-- name: MissingHugelSegments :many
SELECT
	id, name, activity_type, distance, average_grade, maximum_grade, elevation_high, elevation_low, start_latlng, end_latlng, elevation_profile, climb_category, city, state, country, private, hazardous, created_at, updated_at, total_elevation_gain, map_id, total_effort_count, total_athlete_count, total_star_count, fetched_at, friendly_name
FROM
	segments
WHERE
	id = ANY(
		select unnest(segments) as data
		from (SELECT segments FROM competitive_routes WHERE name = 'das-hugel') as hugel
		except
		select segment_id as data
		from segment_efforts WHERE
		    activities_id = $1
	)
`

func (q *sqlQuerier) MissingHugelSegments(ctx context.Context, activityID int64) ([]Segment, error) {
	rows, err := q.db.QueryContext(ctx, missingHugelSegments, activityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Segment
	for rows.Next() {
		var i Segment
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ActivityType,
			&i.Distance,
			&i.AverageGrade,
			&i.MaximumGrade,
			&i.ElevationHigh,
			&i.ElevationLow,
			&i.StartLatlng,
			&i.EndLatlng,
			&i.ElevationProfile,
			&i.ClimbCategory,
			&i.City,
			&i.State,
			&i.Country,
			&i.Private,
			&i.Hazardous,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalElevationGain,
			&i.MapID,
			&i.TotalEffortCount,
			&i.TotalAthleteCount,
			&i.TotalStarCount,
			&i.FetchedAt,
			&i.FriendlyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshHugel2023Activities = `-- name: RefreshHugel2023Activities :exec
REFRESH MATERIALIZED VIEW hugel_activities_2023
`

func (q *sqlQuerier) RefreshHugel2023Activities(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshHugel2023Activities)
	return err
}

const refreshHugelActivities = `-- name: RefreshHugelActivities :exec
REFRESH MATERIALIZED VIEW hugel_activities
`

func (q *sqlQuerier) RefreshHugelActivities(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshHugelActivities)
	return err
}

const refreshHugelLiteActivities = `-- name: RefreshHugelLiteActivities :exec
REFRESH MATERIALIZED VIEW lite_hugel_activities
`

func (q *sqlQuerier) RefreshHugelLiteActivities(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshHugelLiteActivities)
	return err
}

const refreshSuperHugelActivities = `-- name: RefreshSuperHugelActivities :exec
REFRESH MATERIALIZED VIEW super_hugel_activities
`

func (q *sqlQuerier) RefreshSuperHugelActivities(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshSuperHugelActivities)
	return err
}

const superHugelLeaderboard = `-- name: SuperHugelLeaderboard :many
SELECT
	(SELECT min(total_time_seconds) FROM super_hugel_activities) :: BIGINT AS best_time,
	ROW_NUMBER() over(ORDER BY total_time_seconds ASC) AS rank,
	athlete_bests.athlete_id,
	athlete_bests.total_time_seconds,
	athlete_bests.efforts,

	athletes.firstname,
	athletes.lastname,
	athletes.username,
	athletes.profile_pic_link,
	athletes.sex,
	hugel_count.count AS hugel_count
FROM
	(
		SELECT DISTINCT ON (athlete_id)
			athlete_id, segment_ids, total_time_seconds, efforts
		FROM
			super_hugel_activities
		ORDER BY
			athlete_id, total_time_seconds ASC
	) AS athlete_bests
INNER JOIN
	athletes ON athlete_bests.athlete_id = athletes.id
INNER JOIN
	athlete_hugel_count AS hugel_count
		ON hugel_count.athlete_id = athlete_bests.athlete_id
WHERE
	CASE WHEN $1 > 0 THEN athlete_bests.athlete_id = $1 ELSE TRUE END
ORDER BY
	athlete_bests.total_time_seconds ASC
`

type SuperHugelLeaderboardRow struct {
	BestTime         int64           `db:"best_time" json:"best_time"`
	Rank             int64           `db:"rank" json:"rank"`
	AthleteID        int64           `db:"athlete_id" json:"athlete_id"`
	TotalTimeSeconds int64           `db:"total_time_seconds" json:"total_time_seconds"`
	Efforts          json.RawMessage `db:"efforts" json:"efforts"`
	Firstname        string          `db:"firstname" json:"firstname"`
	Lastname         string          `db:"lastname" json:"lastname"`
	Username         string          `db:"username" json:"username"`
	ProfilePicLink   string          `db:"profile_pic_link" json:"profile_pic_link"`
	Sex              string          `db:"sex" json:"sex"`
	HugelCount       int64           `db:"hugel_count" json:"hugel_count"`
}

func (q *sqlQuerier) SuperHugelLeaderboard(ctx context.Context, athleteID interface{}) ([]SuperHugelLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, superHugelLeaderboard, athleteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SuperHugelLeaderboardRow
	for rows.Next() {
		var i SuperHugelLeaderboardRow
		if err := rows.Scan(
			&i.BestTime,
			&i.Rank,
			&i.AthleteID,
			&i.TotalTimeSeconds,
			&i.Efforts,
			&i.Firstname,
			&i.Lastname,
			&i.Username,
			&i.ProfilePicLink,
			&i.Sex,
			&i.HugelCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFailedJob = `-- name: InsertFailedJob :one
INSERT INTO
	failed_jobs(
	id, recorded_at, raw
)
VALUES
	(gen_random_uuid(), Now(), $1)
RETURNING id, recorded_at, raw
`

func (q *sqlQuerier) InsertFailedJob(ctx context.Context, rawJson string) (FailedJob, error) {
	row := q.db.QueryRowContext(ctx, insertFailedJob, rawJson)
	var i FailedJob
	err := row.Scan(&i.ID, &i.RecordedAt, &i.Raw)
	return i, err
}

const totalJobCount = `-- name: TotalJobCount :one
SELECT count(*) FROM gue_jobs
`

func (q *sqlQuerier) TotalJobCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, totalJobCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertMapData = `-- name: UpsertMapData :one
INSERT INTO
	maps(
	updated_at, id, polyline, summary_polyline
)
VALUES
	(Now(), $1, $2, $3)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		polyline =
		    CASE
				WHEN $2 != '' THEN $2
		        ELSE maps.polyline
			END,
		summary_polyline =
			CASE
				WHEN $3 != '' THEN $3
				ELSE maps.summary_polyline
			END
RETURNING id, polyline, summary_polyline, updated_at
`

type UpsertMapDataParams struct {
	ID              string `db:"id" json:"id"`
	Polyline        string `db:"polyline" json:"polyline"`
	SummaryPolyline string `db:"summary_polyline" json:"summary_polyline"`
}

func (q *sqlQuerier) UpsertMapData(ctx context.Context, arg UpsertMapDataParams) (Map, error) {
	row := q.db.QueryRowContext(ctx, upsertMapData, arg.ID, arg.Polyline, arg.SummaryPolyline)
	var i Map
	err := row.Scan(
		&i.ID,
		&i.Polyline,
		&i.SummaryPolyline,
		&i.UpdatedAt,
	)
	return i, err
}

const allCompetitiveRoutes = `-- name: AllCompetitiveRoutes :many
SELECT name, display_name, description, segments FROM competitive_routes
`

func (q *sqlQuerier) AllCompetitiveRoutes(ctx context.Context) ([]CompetitiveRoute, error) {
	rows, err := q.db.QueryContext(ctx, allCompetitiveRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompetitiveRoute
	for rows.Next() {
		var i CompetitiveRoute
		if err := rows.Scan(
			&i.Name,
			&i.DisplayName,
			&i.Description,
			pq.Array(&i.Segments),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bestRouteEfforts = `-- name: BestRouteEfforts :many
SELECT
	activities_id, segment_ids, sum, json_agg
FROM
	(
		SELECT
			hugel_efforts.activities_id,
			-- segment_ids is all the segments this activity has efforts on.
			-- Only segments in the provided list are considered.
			array_agg(segment_id) AS segment_ids,
			-- Sum is the total time of all the efforts.
			sum(elapsed_time),
			-- A json struct containing each effort details.
			json_agg(
					json_build_object(
					    	'effort_id', id,
							'segment_id', segment_id,
							'elapsed_time', elapsed_time,
							'device_watts', device_watts,
					    	'average_watts', average_watts
						)
				)
		FROM
			(
				-- This query returns only the best effort per (segment_id, activity_id)
				SELECT DISTINCT ON (activities_id, segment_id)
					id, athlete_id, segment_id, name, elapsed_time, moving_time, start_date, start_date_local, distance, start_index, end_index, device_watts, average_watts, kom_rank, pr_rank, updated_at, activities_id
				FROM
					segment_efforts
				WHERE
				    -- ARRAY[629046, 6744304, 910045, 628785, 629546, 628842]
					segment_id = any($1 :: bigint[])
				ORDER BY
					activities_id, segment_id, elapsed_time ASC
			) as hugel_efforts
			-- Each activity will now be represented by a single aggregated row
		GROUP BY
			hugel_efforts.activities_id
	) AS merged
WHERE
	segment_ids @> $1 :: bigint[]
`

type BestRouteEffortsRow struct {
	ActivitiesID int64           `db:"activities_id" json:"activities_id"`
	SegmentIds   interface{}     `db:"segment_ids" json:"segment_ids"`
	Sum          int64           `db:"sum" json:"sum"`
	JsonAgg      json.RawMessage `db:"json_agg" json:"json_agg"`
}

// BestRouteEfforts returns all activities that have efforts on all the provided segments.
// The returned activities include the best effort for each segment.
// This isn't used in the app, but is the foundation for the hugel view.
func (q *sqlQuerier) BestRouteEfforts(ctx context.Context, expectedSegments []int64) ([]BestRouteEffortsRow, error) {
	rows, err := q.db.QueryContext(ctx, bestRouteEfforts, pq.Array(expectedSegments))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BestRouteEffortsRow
	for rows.Next() {
		var i BestRouteEffortsRow
		if err := rows.Scan(
			&i.ActivitiesID,
			&i.SegmentIds,
			&i.Sum,
			&i.JsonAgg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestPersonalSegmentEffort = `-- name: GetBestPersonalSegmentEffort :many
SELECT DISTINCT ON (segment_efforts.athlete_id, segment_efforts.segment_id)
	id, athlete_id, segment_id, name, elapsed_time, moving_time, start_date, start_date_local, distance, start_index, end_index, device_watts, average_watts, kom_rank, pr_rank, updated_at, activities_id
FROM
	segment_efforts
WHERE
	athlete_id = $1 AND
	segment_id = ANY($2::bigint[])
ORDER BY
	segment_efforts.athlete_id, segment_efforts.segment_id, elapsed_time ASC
`

type GetBestPersonalSegmentEffortParams struct {
	AthleteID  int64   `db:"athlete_id" json:"athlete_id"`
	SegmentIds []int64 `db:"segment_ids" json:"segment_ids"`
}

func (q *sqlQuerier) GetBestPersonalSegmentEffort(ctx context.Context, arg GetBestPersonalSegmentEffortParams) ([]SegmentEffort, error) {
	rows, err := q.db.QueryContext(ctx, getBestPersonalSegmentEffort, arg.AthleteID, pq.Array(arg.SegmentIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SegmentEffort
	for rows.Next() {
		var i SegmentEffort
		if err := rows.Scan(
			&i.ID,
			&i.AthleteID,
			&i.SegmentID,
			&i.Name,
			&i.ElapsedTime,
			&i.MovingTime,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Distance,
			&i.StartIndex,
			&i.EndIndex,
			&i.DeviceWatts,
			&i.AverageWatts,
			&i.KomRank,
			&i.PrRank,
			&i.UpdatedAt,
			&i.ActivitiesID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSegments = `-- name: GetSegments :many
SELECT
    segments.id, segments.name, segments.activity_type, segments.distance, segments.average_grade, segments.maximum_grade, segments.elevation_high, segments.elevation_low, segments.start_latlng, segments.end_latlng, segments.elevation_profile, segments.climb_category, segments.city, segments.state, segments.country, segments.private, segments.hazardous, segments.created_at, segments.updated_at, segments.total_elevation_gain, segments.map_id, segments.total_effort_count, segments.total_athlete_count, segments.total_star_count, segments.fetched_at, segments.friendly_name, maps.id, maps.polyline, maps.summary_polyline, maps.updated_at
FROM
    segments
LEFT JOIN
	maps ON segments.map_id = maps.id
WHERE segments.id = ANY($1::bigint[])
`

type GetSegmentsRow struct {
	Segment Segment `db:"segment" json:"segment"`
	Map     Map     `db:"map" json:"map"`
}

func (q *sqlQuerier) GetSegments(ctx context.Context, segmentIds []int64) ([]GetSegmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSegments, pq.Array(segmentIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSegmentsRow
	for rows.Next() {
		var i GetSegmentsRow
		if err := rows.Scan(
			&i.Segment.ID,
			&i.Segment.Name,
			&i.Segment.ActivityType,
			&i.Segment.Distance,
			&i.Segment.AverageGrade,
			&i.Segment.MaximumGrade,
			&i.Segment.ElevationHigh,
			&i.Segment.ElevationLow,
			&i.Segment.StartLatlng,
			&i.Segment.EndLatlng,
			&i.Segment.ElevationProfile,
			&i.Segment.ClimbCategory,
			&i.Segment.City,
			&i.Segment.State,
			&i.Segment.Country,
			&i.Segment.Private,
			&i.Segment.Hazardous,
			&i.Segment.CreatedAt,
			&i.Segment.UpdatedAt,
			&i.Segment.TotalElevationGain,
			&i.Segment.MapID,
			&i.Segment.TotalEffortCount,
			&i.Segment.TotalAthleteCount,
			&i.Segment.TotalStarCount,
			&i.Segment.FetchedAt,
			&i.Segment.FriendlyName,
			&i.Map.ID,
			&i.Map.Polyline,
			&i.Map.SummaryPolyline,
			&i.Map.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadedSegments = `-- name: LoadedSegments :many
SELECT id, fetched_at FROM segments
`

type LoadedSegmentsRow struct {
	ID        int64     `db:"id" json:"id"`
	FetchedAt time.Time `db:"fetched_at" json:"fetched_at"`
}

func (q *sqlQuerier) LoadedSegments(ctx context.Context) ([]LoadedSegmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, loadedSegments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadedSegmentsRow
	for rows.Next() {
		var i LoadedSegmentsRow
		if err := rows.Scan(&i.ID, &i.FetchedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const starSegments = `-- name: StarSegments :exec
INSERT INTO
	starred_segments(
		updated_at,
		athlete_id,
		segment_id,
	    starred
	)

SELECT updated_at, athlete_id, segment_id, starred FROM
(
	SELECT
		Now() AS updated_at,
		unnest($1::bigint[]) AS athlete_id,
		unnest($2::bigint[]) AS segment_id,
		unnest($3::boolean[]) AS starred
) AS inserting_rows
WHERE
    segment_id = ANY(SELECT id FROM segments)
ON CONFLICT
	(athlete_id, segment_id)
	DO UPDATE SET
		updated_at = Now(),
		starred = EXCLUDED.starred
`

type StarSegmentsParams struct {
	AthleteID []int64 `db:"athlete_id" json:"athlete_id"`
	SegmentID []int64 `db:"segment_id" json:"segment_id"`
	Starred   []bool  `db:"starred" json:"starred"`
}

func (q *sqlQuerier) StarSegments(ctx context.Context, arg StarSegmentsParams) error {
	_, err := q.db.ExecContext(ctx, starSegments, pq.Array(arg.AthleteID), pq.Array(arg.SegmentID), pq.Array(arg.Starred))
	return err
}

const upsertSegment = `-- name: UpsertSegment :one
INSERT INTO
	segments(
	id, name, activity_type, distance, average_grade,
	maximum_grade, elevation_high, elevation_low, start_latlng, end_latlng,
	elevation_profile, climb_category, city, state, country, private, hazardous,
	created_at, updated_at, total_elevation_gain, map_id, total_effort_count,
	total_athlete_count, total_star_count, fetched_at
	)
VALUES
	($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
	 $18, $19, $20, $21, $22, $23, $24, Now())
ON CONFLICT
	(id)
	DO UPDATE SET
	name = CASE WHEN $2 != '' THEN $2 ELSE segments.name END,
	activity_type = CASE WHEN $3 != '' THEN $3 ELSE segments.activity_type END,
	distance = CASE WHEN $4 != 0 THEN $4 ELSE segments.distance END,
	average_grade = CASE WHEN $5 != 0 THEN $5 ELSE segments.average_grade END,
	maximum_grade = CASE WHEN $6 != 0 THEN $6 ELSE segments.maximum_grade END,
	elevation_high = CASE WHEN $7 != 0 THEN $7 ELSE segments.elevation_high END,
	elevation_low = CASE WHEN $8 != 0 THEN $8 ELSE segments.elevation_low END,
	start_latlng = $9,
	end_latlng = $10,
	elevation_profile = CASE WHEN $11 != '' THEN $11 ELSE segments.elevation_profile END,
	climb_category = CASE WHEN $12 != 0 THEN $12 ELSE segments.climb_category END,
	city = CASE WHEN $13 != '' THEN $13 ELSE segments.city END,
	state = CASE WHEN $14 != '' THEN $14 ELSE segments.state END,
	country = CASE WHEN $15 != '' THEN $15 ELSE segments.country END,
	private = $16,
	hazardous = $17,
	created_at = CASE WHEN $18 != '0001-01-01 00:00:00+00' THEN $18 ELSE segments.created_at END,
	updated_at = CASE WHEN $19 != '0001-01-01 00:00:00+00' THEN $18 ELSE segments.updated_at END,
	total_elevation_gain = CASE WHEN $20 != 0 THEN $20 ELSE segments.total_elevation_gain END,
	map_id = CASE WHEN $21 != '' THEN $21 ELSE segments.map_id END,
	total_effort_count = CASE WHEN $22 != 0 THEN $22 ELSE segments.total_effort_count END,
	total_athlete_count = CASE WHEN $23 != 0 THEN $23 ELSE segments.total_athlete_count END,
	total_star_count = CASE WHEN $24 != 0 THEN $24 ELSE segments.total_star_count END,
	fetched_at = Now()

RETURNING id, name, activity_type, distance, average_grade, maximum_grade, elevation_high, elevation_low, start_latlng, end_latlng, elevation_profile, climb_category, city, state, country, private, hazardous, created_at, updated_at, total_elevation_gain, map_id, total_effort_count, total_athlete_count, total_star_count, fetched_at, friendly_name
`

type UpsertSegmentParams struct {
	ID                 int64     `db:"id" json:"id"`
	Name               string    `db:"name" json:"name"`
	ActivityType       string    `db:"activity_type" json:"activity_type"`
	Distance           float64   `db:"distance" json:"distance"`
	AverageGrade       float64   `db:"average_grade" json:"average_grade"`
	MaximumGrade       float64   `db:"maximum_grade" json:"maximum_grade"`
	ElevationHigh      float64   `db:"elevation_high" json:"elevation_high"`
	ElevationLow       float64   `db:"elevation_low" json:"elevation_low"`
	StartLatlng        Floats    `db:"start_latlng" json:"start_latlng"`
	EndLatlng          Floats    `db:"end_latlng" json:"end_latlng"`
	ElevationProfile   string    `db:"elevation_profile" json:"elevation_profile"`
	ClimbCategory      int32     `db:"climb_category" json:"climb_category"`
	City               string    `db:"city" json:"city"`
	State              string    `db:"state" json:"state"`
	Country            string    `db:"country" json:"country"`
	Private            bool      `db:"private" json:"private"`
	Hazardous          bool      `db:"hazardous" json:"hazardous"`
	CreatedAt          time.Time `db:"created_at" json:"created_at"`
	UpdatedAt          time.Time `db:"updated_at" json:"updated_at"`
	TotalElevationGain float64   `db:"total_elevation_gain" json:"total_elevation_gain"`
	MapID              string    `db:"map_id" json:"map_id"`
	TotalEffortCount   int32     `db:"total_effort_count" json:"total_effort_count"`
	TotalAthleteCount  int32     `db:"total_athlete_count" json:"total_athlete_count"`
	TotalStarCount     int32     `db:"total_star_count" json:"total_star_count"`
}

func (q *sqlQuerier) UpsertSegment(ctx context.Context, arg UpsertSegmentParams) (Segment, error) {
	row := q.db.QueryRowContext(ctx, upsertSegment,
		arg.ID,
		arg.Name,
		arg.ActivityType,
		arg.Distance,
		arg.AverageGrade,
		arg.MaximumGrade,
		arg.ElevationHigh,
		arg.ElevationLow,
		arg.StartLatlng,
		arg.EndLatlng,
		arg.ElevationProfile,
		arg.ClimbCategory,
		arg.City,
		arg.State,
		arg.Country,
		arg.Private,
		arg.Hazardous,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.TotalElevationGain,
		arg.MapID,
		arg.TotalEffortCount,
		arg.TotalAthleteCount,
		arg.TotalStarCount,
	)
	var i Segment
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ActivityType,
		&i.Distance,
		&i.AverageGrade,
		&i.MaximumGrade,
		&i.ElevationHigh,
		&i.ElevationLow,
		&i.StartLatlng,
		&i.EndLatlng,
		&i.ElevationProfile,
		&i.ClimbCategory,
		&i.City,
		&i.State,
		&i.Country,
		&i.Private,
		&i.Hazardous,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TotalElevationGain,
		&i.MapID,
		&i.TotalEffortCount,
		&i.TotalAthleteCount,
		&i.TotalStarCount,
		&i.FetchedAt,
		&i.FriendlyName,
	)
	return i, err
}

const upsertSegmentEffort = `-- name: UpsertSegmentEffort :one
INSERT INTO
	segment_efforts(
		updated_at,
		id, athlete_id, segment_id, name, elapsed_time,
		moving_time, start_date, start_date_local, distance,
		start_index, end_index, device_watts, average_watts,
		kom_rank, pr_rank, activities_id
	)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		athlete_id = $2,
		segment_id = $3,
		name = $4,
		elapsed_time = $5,
		moving_time = $6,
		start_date = $7,
		start_date_local = $8,
		distance = $9,
		start_index = $10,
		end_index = $11,
		device_watts = $12,
		average_watts = $13,
		kom_rank = $14,
		pr_rank = $15,
		activities_id = $16
	RETURNING id, athlete_id, segment_id, name, elapsed_time, moving_time, start_date, start_date_local, distance, start_index, end_index, device_watts, average_watts, kom_rank, pr_rank, updated_at, activities_id
`

type UpsertSegmentEffortParams struct {
	ID             int64         `db:"id" json:"id"`
	AthleteID      int64         `db:"athlete_id" json:"athlete_id"`
	SegmentID      int64         `db:"segment_id" json:"segment_id"`
	Name           string        `db:"name" json:"name"`
	ElapsedTime    float64       `db:"elapsed_time" json:"elapsed_time"`
	MovingTime     float64       `db:"moving_time" json:"moving_time"`
	StartDate      time.Time     `db:"start_date" json:"start_date"`
	StartDateLocal time.Time     `db:"start_date_local" json:"start_date_local"`
	Distance       float64       `db:"distance" json:"distance"`
	StartIndex     int32         `db:"start_index" json:"start_index"`
	EndIndex       int32         `db:"end_index" json:"end_index"`
	DeviceWatts    bool          `db:"device_watts" json:"device_watts"`
	AverageWatts   float64       `db:"average_watts" json:"average_watts"`
	KomRank        sql.NullInt32 `db:"kom_rank" json:"kom_rank"`
	PrRank         sql.NullInt32 `db:"pr_rank" json:"pr_rank"`
	ActivitiesID   int64         `db:"activities_id" json:"activities_id"`
}

func (q *sqlQuerier) UpsertSegmentEffort(ctx context.Context, arg UpsertSegmentEffortParams) (SegmentEffort, error) {
	row := q.db.QueryRowContext(ctx, upsertSegmentEffort,
		arg.ID,
		arg.AthleteID,
		arg.SegmentID,
		arg.Name,
		arg.ElapsedTime,
		arg.MovingTime,
		arg.StartDate,
		arg.StartDateLocal,
		arg.Distance,
		arg.StartIndex,
		arg.EndIndex,
		arg.DeviceWatts,
		arg.AverageWatts,
		arg.KomRank,
		arg.PrRank,
		arg.ActivitiesID,
	)
	var i SegmentEffort
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.SegmentID,
		&i.Name,
		&i.ElapsedTime,
		&i.MovingTime,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Distance,
		&i.StartIndex,
		&i.EndIndex,
		&i.DeviceWatts,
		&i.AverageWatts,
		&i.KomRank,
		&i.PrRank,
		&i.UpdatedAt,
		&i.ActivitiesID,
	)
	return i, err
}

const insertWebhookDump = `-- name: InsertWebhookDump :one
INSERT INTO
	webhook_dump(
	id, recorded_at, raw
)
VALUES
	(gen_random_uuid(), Now(), $1)
RETURNING id, recorded_at, raw
`

func (q *sqlQuerier) InsertWebhookDump(ctx context.Context, rawJson string) (WebhookDump, error) {
	row := q.db.QueryRowContext(ctx, insertWebhookDump, rawJson)
	var i WebhookDump
	err := row.Scan(&i.ID, &i.RecordedAt, &i.Raw)
	return i, err
}
