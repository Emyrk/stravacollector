// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const deleteActivity = `-- name: DeleteActivity :one
DELETE FROM
	activity_summary
WHERE
	id = $1
RETURNING id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate
`

func (q *sqlQuerier) DeleteActivity(ctx context.Context, id int64) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, deleteActivity, id)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
	)
	return i, err
}

const getActivityDetail = `-- name: GetActivityDetail :one
SELECT
	id, athlete_id, start_latlng, end_latlng, from_accepted_tag, average_cadence, average_temp, average_watts, weighted_average_watts, kilojoules, max_watts, elev_high, elev_low, suffer_score, calories, embed_token, segment_leaderboard_opt_out, leaderboard_opt_out, num_segment_efforts, premium_fetch, updated_at, map_id, source
FROM
	activity_detail
WHERE
	id = $1
`

func (q *sqlQuerier) GetActivityDetail(ctx context.Context, id int64) (ActivityDetail, error) {
	row := q.db.QueryRowContext(ctx, getActivityDetail, id)
	var i ActivityDetail
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		pq.Array(&i.StartLatlng),
		pq.Array(&i.EndLatlng),
		&i.FromAcceptedTag,
		&i.AverageCadence,
		&i.AverageTemp,
		&i.AverageWatts,
		&i.WeightedAverageWatts,
		&i.Kilojoules,
		&i.MaxWatts,
		&i.ElevHigh,
		&i.ElevLow,
		&i.SufferScore,
		&i.Calories,
		&i.EmbedToken,
		&i.SegmentLeaderboardOptOut,
		&i.LeaderboardOptOut,
		&i.NumSegmentEfforts,
		&i.PremiumFetch,
		&i.UpdatedAt,
		&i.MapID,
		&i.Source,
	)
	return i, err
}

const getActivitySummary = `-- name: GetActivitySummary :one
SELECT
	id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate
FROM
    activity_summary
WHERE
    id = $1
`

func (q *sqlQuerier) GetActivitySummary(ctx context.Context, id int64) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, getActivitySummary, id)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
	)
	return i, err
}

const updateActivityName = `-- name: UpdateActivityName :exec
UPDATE activity_summary
SET
    name = $2
WHERE
    id = $1
`

type UpdateActivityNameParams struct {
	ID   int64  `db:"id" json:"id"`
	Name string `db:"name" json:"name"`
}

func (q *sqlQuerier) UpdateActivityName(ctx context.Context, arg UpdateActivityNameParams) error {
	_, err := q.db.ExecContext(ctx, updateActivityName, arg.ID, arg.Name)
	return err
}

const upsertActivityDetail = `-- name: UpsertActivityDetail :one
INSERT INTO
	activity_detail(
		updated_at, id, athlete_id, start_latlng,
		end_latlng, from_accepted_tag, average_cadence, average_temp,
		average_watts, weighted_average_watts, kilojoules, max_watts,
	    elev_high, elev_low, suffer_score, embed_token,
	    segment_leaderboard_opt_out, leaderboard_opt_out, num_segment_efforts,
	    premium_fetch, map_id, calories, source
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
	 $18, $19, $20, $21, $22)
ON CONFLICT
	(id)
	DO UPDATE SET
	updated_at = Now(),
	athlete_id = $2,
	start_latlng = $3,
	end_latlng = $4,
	from_accepted_tag = $5,
	average_cadence = $6,
	average_temp = $7,
	average_watts = $8,
	weighted_average_watts = $9,
	kilojoules = $10,
	max_watts = $11,
	elev_high = $12,
	elev_low = $13,
	suffer_score = $14,
	embed_token = $15,
	segment_leaderboard_opt_out = $16,
	leaderboard_opt_out = $17,
	num_segment_efforts = $18,
	premium_fetch = $19,
	map_id = $20,
	calories = $21,
	source = $22
RETURNING id, athlete_id, start_latlng, end_latlng, from_accepted_tag, average_cadence, average_temp, average_watts, weighted_average_watts, kilojoules, max_watts, elev_high, elev_low, suffer_score, calories, embed_token, segment_leaderboard_opt_out, leaderboard_opt_out, num_segment_efforts, premium_fetch, updated_at, map_id, source
`

type UpsertActivityDetailParams struct {
	ID                       int64                `db:"id" json:"id"`
	AthleteID                int64                `db:"athlete_id" json:"athlete_id"`
	StartLatlng              []float64            `db:"start_latlng" json:"start_latlng"`
	EndLatlng                []float64            `db:"end_latlng" json:"end_latlng"`
	FromAcceptedTag          bool                 `db:"from_accepted_tag" json:"from_accepted_tag"`
	AverageCadence           float64              `db:"average_cadence" json:"average_cadence"`
	AverageTemp              float64              `db:"average_temp" json:"average_temp"`
	AverageWatts             float64              `db:"average_watts" json:"average_watts"`
	WeightedAverageWatts     float64              `db:"weighted_average_watts" json:"weighted_average_watts"`
	Kilojoules               float64              `db:"kilojoules" json:"kilojoules"`
	MaxWatts                 float64              `db:"max_watts" json:"max_watts"`
	ElevHigh                 float64              `db:"elev_high" json:"elev_high"`
	ElevLow                  float64              `db:"elev_low" json:"elev_low"`
	SufferScore              int32                `db:"suffer_score" json:"suffer_score"`
	EmbedToken               string               `db:"embed_token" json:"embed_token"`
	SegmentLeaderboardOptOut bool                 `db:"segment_leaderboard_opt_out" json:"segment_leaderboard_opt_out"`
	LeaderboardOptOut        bool                 `db:"leaderboard_opt_out" json:"leaderboard_opt_out"`
	NumSegmentEfforts        int32                `db:"num_segment_efforts" json:"num_segment_efforts"`
	PremiumFetch             bool                 `db:"premium_fetch" json:"premium_fetch"`
	MapID                    string               `db:"map_id" json:"map_id"`
	Calories                 float64              `db:"calories" json:"calories"`
	Source                   ActivityDetailSource `db:"source" json:"source"`
}

func (q *sqlQuerier) UpsertActivityDetail(ctx context.Context, arg UpsertActivityDetailParams) (ActivityDetail, error) {
	row := q.db.QueryRowContext(ctx, upsertActivityDetail,
		arg.ID,
		arg.AthleteID,
		pq.Array(arg.StartLatlng),
		pq.Array(arg.EndLatlng),
		arg.FromAcceptedTag,
		arg.AverageCadence,
		arg.AverageTemp,
		arg.AverageWatts,
		arg.WeightedAverageWatts,
		arg.Kilojoules,
		arg.MaxWatts,
		arg.ElevHigh,
		arg.ElevLow,
		arg.SufferScore,
		arg.EmbedToken,
		arg.SegmentLeaderboardOptOut,
		arg.LeaderboardOptOut,
		arg.NumSegmentEfforts,
		arg.PremiumFetch,
		arg.MapID,
		arg.Calories,
		arg.Source,
	)
	var i ActivityDetail
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		pq.Array(&i.StartLatlng),
		pq.Array(&i.EndLatlng),
		&i.FromAcceptedTag,
		&i.AverageCadence,
		&i.AverageTemp,
		&i.AverageWatts,
		&i.WeightedAverageWatts,
		&i.Kilojoules,
		&i.MaxWatts,
		&i.ElevHigh,
		&i.ElevLow,
		&i.SufferScore,
		&i.Calories,
		&i.EmbedToken,
		&i.SegmentLeaderboardOptOut,
		&i.LeaderboardOptOut,
		&i.NumSegmentEfforts,
		&i.PremiumFetch,
		&i.UpdatedAt,
		&i.MapID,
		&i.Source,
	)
	return i, err
}

const upsertActivitySummary = `-- name: UpsertActivitySummary :one
INSERT INTO
	activity_summary(
		updated_at, id, athlete_id, upload_id, external_id, name,
	    distance, moving_time, elapsed_time, total_elevation_gain,
	    activity_type, sport_type, workout_type, start_date,
	    start_date_local, timezone, utc_offset, achievement_count,
	    kudos_count, comment_count, athlete_count, photo_count, map_id,
	    trainer, commute, manual, private, flagged, gear_id, average_speed,
	    max_speed, device_watts, has_heartrate, pr_count, total_photo_count,
	    average_heartrate, max_heartrate
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
	 $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		athlete_id = $2,
		upload_id = $3,
		external_id = $4,
		name = $5,
		distance = $6,
		moving_time = $7,
		elapsed_time = $8,
		total_elevation_gain = $9,
		activity_type = $10,
		sport_type = $11,
		workout_type = $12,
		start_date = $13,
		start_date_local = $14,
		timezone = $15,
		utc_offset = $16,
		achievement_count = $17,
		kudos_count = $18,
		comment_count = $19,
		athlete_count = $20,
		photo_count = $21,
		map_id = $22,
		trainer = $23,
		commute = $24,
		manual = $25,
		private = $26,
		flagged = $27,
		gear_id = $28,
		average_speed = $29,
		max_speed = $30,
		device_watts = $31,
		has_heartrate = $32,
		pr_count = $33,
		total_photo_count = $34,
		average_heartrate = $35,
		max_heartrate = $36
RETURNING id, athlete_id, upload_id, external_id, name, distance, moving_time, elapsed_time, total_elevation_gain, activity_type, sport_type, workout_type, start_date, start_date_local, timezone, utc_offset, achievement_count, kudos_count, comment_count, athlete_count, photo_count, map_id, trainer, commute, manual, private, flagged, gear_id, average_speed, max_speed, device_watts, has_heartrate, pr_count, total_photo_count, updated_at, average_heartrate, max_heartrate
`

type UpsertActivitySummaryParams struct {
	ID                 int64     `db:"id" json:"id"`
	AthleteID          int64     `db:"athlete_id" json:"athlete_id"`
	UploadID           int64     `db:"upload_id" json:"upload_id"`
	ExternalID         string    `db:"external_id" json:"external_id"`
	Name               string    `db:"name" json:"name"`
	Distance           float64   `db:"distance" json:"distance"`
	MovingTime         float64   `db:"moving_time" json:"moving_time"`
	ElapsedTime        float64   `db:"elapsed_time" json:"elapsed_time"`
	TotalElevationGain float64   `db:"total_elevation_gain" json:"total_elevation_gain"`
	ActivityType       string    `db:"activity_type" json:"activity_type"`
	SportType          string    `db:"sport_type" json:"sport_type"`
	WorkoutType        int32     `db:"workout_type" json:"workout_type"`
	StartDate          time.Time `db:"start_date" json:"start_date"`
	StartDateLocal     time.Time `db:"start_date_local" json:"start_date_local"`
	Timezone           string    `db:"timezone" json:"timezone"`
	UtcOffset          float64   `db:"utc_offset" json:"utc_offset"`
	AchievementCount   int32     `db:"achievement_count" json:"achievement_count"`
	KudosCount         int32     `db:"kudos_count" json:"kudos_count"`
	CommentCount       int32     `db:"comment_count" json:"comment_count"`
	AthleteCount       int32     `db:"athlete_count" json:"athlete_count"`
	PhotoCount         int32     `db:"photo_count" json:"photo_count"`
	MapID              string    `db:"map_id" json:"map_id"`
	Trainer            bool      `db:"trainer" json:"trainer"`
	Commute            bool      `db:"commute" json:"commute"`
	Manual             bool      `db:"manual" json:"manual"`
	Private            bool      `db:"private" json:"private"`
	Flagged            bool      `db:"flagged" json:"flagged"`
	GearID             string    `db:"gear_id" json:"gear_id"`
	AverageSpeed       float64   `db:"average_speed" json:"average_speed"`
	MaxSpeed           float64   `db:"max_speed" json:"max_speed"`
	DeviceWatts        bool      `db:"device_watts" json:"device_watts"`
	HasHeartrate       bool      `db:"has_heartrate" json:"has_heartrate"`
	PrCount            int32     `db:"pr_count" json:"pr_count"`
	TotalPhotoCount    int32     `db:"total_photo_count" json:"total_photo_count"`
	AverageHeartrate   float64   `db:"average_heartrate" json:"average_heartrate"`
	MaxHeartrate       float64   `db:"max_heartrate" json:"max_heartrate"`
}

func (q *sqlQuerier) UpsertActivitySummary(ctx context.Context, arg UpsertActivitySummaryParams) (ActivitySummary, error) {
	row := q.db.QueryRowContext(ctx, upsertActivitySummary,
		arg.ID,
		arg.AthleteID,
		arg.UploadID,
		arg.ExternalID,
		arg.Name,
		arg.Distance,
		arg.MovingTime,
		arg.ElapsedTime,
		arg.TotalElevationGain,
		arg.ActivityType,
		arg.SportType,
		arg.WorkoutType,
		arg.StartDate,
		arg.StartDateLocal,
		arg.Timezone,
		arg.UtcOffset,
		arg.AchievementCount,
		arg.KudosCount,
		arg.CommentCount,
		arg.AthleteCount,
		arg.PhotoCount,
		arg.MapID,
		arg.Trainer,
		arg.Commute,
		arg.Manual,
		arg.Private,
		arg.Flagged,
		arg.GearID,
		arg.AverageSpeed,
		arg.MaxSpeed,
		arg.DeviceWatts,
		arg.HasHeartrate,
		arg.PrCount,
		arg.TotalPhotoCount,
		arg.AverageHeartrate,
		arg.MaxHeartrate,
	)
	var i ActivitySummary
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.UploadID,
		&i.ExternalID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.ActivityType,
		&i.SportType,
		&i.WorkoutType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.UtcOffset,
		&i.AchievementCount,
		&i.KudosCount,
		&i.CommentCount,
		&i.AthleteCount,
		&i.PhotoCount,
		&i.MapID,
		&i.Trainer,
		&i.Commute,
		&i.Manual,
		&i.Private,
		&i.Flagged,
		&i.GearID,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.DeviceWatts,
		&i.HasHeartrate,
		&i.PrCount,
		&i.TotalPhotoCount,
		&i.UpdatedAt,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
	)
	return i, err
}

const getAthlete = `-- name: GetAthlete :one
SELECT id, summit, username, firstname, lastname, sex, city, state, country, follow_count, friend_count, measurement_preference, ftp, weight, clubs, created_at, updated_at, fetched_at, profile_pic_link, profile_pic_link_medium FROM athletes WHERE id = $1
`

func (q *sqlQuerier) GetAthlete(ctx context.Context, athleteID int64) (Athlete, error) {
	row := q.db.QueryRowContext(ctx, getAthlete, athleteID)
	var i Athlete
	err := row.Scan(
		&i.ID,
		&i.Summit,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Sex,
		&i.City,
		&i.State,
		&i.Country,
		&i.FollowCount,
		&i.FriendCount,
		&i.MeasurementPreference,
		&i.Ftp,
		&i.Weight,
		&i.Clubs,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FetchedAt,
		&i.ProfilePicLink,
		&i.ProfilePicLinkMedium,
	)
	return i, err
}

const getAthleteLoad = `-- name: GetAthleteLoad :one
SELECT athlete_id, last_backload_activity_start, last_load_attempt, last_load_incomplete, last_load_error, activites_loaded_last_attempt, earliest_activity, earliest_activity_done FROM athlete_load WHERE athlete_id = $1
`

func (q *sqlQuerier) GetAthleteLoad(ctx context.Context, athleteID int64) (AthleteLoad, error) {
	row := q.db.QueryRowContext(ctx, getAthleteLoad, athleteID)
	var i AthleteLoad
	err := row.Scan(
		&i.AthleteID,
		&i.LastBackloadActivityStart,
		&i.LastLoadAttempt,
		&i.LastLoadIncomplete,
		&i.LastLoadError,
		&i.ActivitesLoadedLastAttempt,
		&i.EarliestActivity,
		&i.EarliestActivityDone,
	)
	return i, err
}

const getAthleteLogin = `-- name: GetAthleteLogin :one
SELECT athlete_id, summit, provider_id, created_at, updated_at, oauth_access_token, oauth_refresh_token, oauth_expiry, oauth_token_type, id FROM athlete_logins WHERE athlete_id = $1
`

func (q *sqlQuerier) GetAthleteLogin(ctx context.Context, athleteID int64) (AthleteLogin, error) {
	row := q.db.QueryRowContext(ctx, getAthleteLogin, athleteID)
	var i AthleteLogin
	err := row.Scan(
		&i.AthleteID,
		&i.Summit,
		&i.ProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthAccessToken,
		&i.OauthRefreshToken,
		&i.OauthExpiry,
		&i.OauthTokenType,
		&i.ID,
	)
	return i, err
}

const getAthleteNeedsLoad = `-- name: GetAthleteNeedsLoad :one
SELECT
    athlete_load.athlete_id, athlete_load.last_backload_activity_start, athlete_load.last_load_attempt, athlete_load.last_load_incomplete, athlete_load.last_load_error, athlete_load.activites_loaded_last_attempt, athlete_load.earliest_activity, athlete_load.earliest_activity_done, athlete_logins.athlete_id, athlete_logins.summit, athlete_logins.provider_id, athlete_logins.created_at, athlete_logins.updated_at, athlete_logins.oauth_access_token, athlete_logins.oauth_refresh_token, athlete_logins.oauth_expiry, athlete_logins.oauth_token_type, athlete_logins.id
FROM
	athlete_load
INNER JOIN
	athlete_logins
ON
    athlete_load.athlete_id = athlete_logins.athlete_id
ORDER BY
    -- Athletes with oldest load attempt first.
	(last_load_incomplete OR not earliest_activity_done, last_load_attempt)
LIMIT 1
`

type GetAthleteNeedsLoadRow struct {
	AthleteLoad  AthleteLoad  `db:"athleteload" json:"athleteload"`
	AthleteLogin AthleteLogin `db:"athletelogin" json:"athletelogin"`
}

func (q *sqlQuerier) GetAthleteNeedsLoad(ctx context.Context) (GetAthleteNeedsLoadRow, error) {
	row := q.db.QueryRowContext(ctx, getAthleteNeedsLoad)
	var i GetAthleteNeedsLoadRow
	err := row.Scan(
		&i.AthleteLoad.AthleteID,
		&i.AthleteLoad.LastBackloadActivityStart,
		&i.AthleteLoad.LastLoadAttempt,
		&i.AthleteLoad.LastLoadIncomplete,
		&i.AthleteLoad.LastLoadError,
		&i.AthleteLoad.ActivitesLoadedLastAttempt,
		&i.AthleteLoad.EarliestActivity,
		&i.AthleteLoad.EarliestActivityDone,
		&i.AthleteLogin.AthleteID,
		&i.AthleteLogin.Summit,
		&i.AthleteLogin.ProviderID,
		&i.AthleteLogin.CreatedAt,
		&i.AthleteLogin.UpdatedAt,
		&i.AthleteLogin.OauthAccessToken,
		&i.AthleteLogin.OauthRefreshToken,
		&i.AthleteLogin.OauthExpiry,
		&i.AthleteLogin.OauthTokenType,
		&i.AthleteLogin.ID,
	)
	return i, err
}

const upsertAthlete = `-- name: UpsertAthlete :one
INSERT INTO
	athletes(
	fetched_at, id, created_at, updated_at,
		summit, username, firstname, lastname, sex, city, state, country,
		follow_count, friend_count, measurement_preference, ftp, weight, clubs,
		profile_pic_link, profile_pic_link_medium
)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
ON CONFLICT
	(id)
	DO UPDATE SET
		fetched_at = Now(),
		created_at = $2,
		updated_at = $3,
		summit = $4,
		username = $5,
		firstname = $6,
		lastname = $7,
		sex = $8,
		city = $9,
		state = $10,
		country = $11,
		follow_count = $12,
		friend_count = $13,
		measurement_preference = $14,
		ftp = $15,
		weight = $16,
		clubs = $17,
		profile_pic_link = $18,
		profile_pic_link_medium = $19
RETURNING id, summit, username, firstname, lastname, sex, city, state, country, follow_count, friend_count, measurement_preference, ftp, weight, clubs, created_at, updated_at, fetched_at, profile_pic_link, profile_pic_link_medium
`

type UpsertAthleteParams struct {
	ID                    int64           `db:"id" json:"id"`
	CreatedAt             time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt             time.Time       `db:"updated_at" json:"updated_at"`
	Summit                bool            `db:"summit" json:"summit"`
	Username              string          `db:"username" json:"username"`
	Firstname             string          `db:"firstname" json:"firstname"`
	Lastname              string          `db:"lastname" json:"lastname"`
	Sex                   string          `db:"sex" json:"sex"`
	City                  string          `db:"city" json:"city"`
	State                 string          `db:"state" json:"state"`
	Country               string          `db:"country" json:"country"`
	FollowCount           int32           `db:"follow_count" json:"follow_count"`
	FriendCount           int32           `db:"friend_count" json:"friend_count"`
	MeasurementPreference string          `db:"measurement_preference" json:"measurement_preference"`
	Ftp                   float64         `db:"ftp" json:"ftp"`
	Weight                float64         `db:"weight" json:"weight"`
	Clubs                 json.RawMessage `db:"clubs" json:"clubs"`
	ProfilePicLink        string          `db:"profile_pic_link" json:"profile_pic_link"`
	ProfilePicLinkMedium  string          `db:"profile_pic_link_medium" json:"profile_pic_link_medium"`
}

func (q *sqlQuerier) UpsertAthlete(ctx context.Context, arg UpsertAthleteParams) (Athlete, error) {
	row := q.db.QueryRowContext(ctx, upsertAthlete,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Summit,
		arg.Username,
		arg.Firstname,
		arg.Lastname,
		arg.Sex,
		arg.City,
		arg.State,
		arg.Country,
		arg.FollowCount,
		arg.FriendCount,
		arg.MeasurementPreference,
		arg.Ftp,
		arg.Weight,
		arg.Clubs,
		arg.ProfilePicLink,
		arg.ProfilePicLinkMedium,
	)
	var i Athlete
	err := row.Scan(
		&i.ID,
		&i.Summit,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Sex,
		&i.City,
		&i.State,
		&i.Country,
		&i.FollowCount,
		&i.FriendCount,
		&i.MeasurementPreference,
		&i.Ftp,
		&i.Weight,
		&i.Clubs,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FetchedAt,
		&i.ProfilePicLink,
		&i.ProfilePicLinkMedium,
	)
	return i, err
}

const upsertAthleteLoad = `-- name: UpsertAthleteLoad :one
INSERT INTO
	athlete_load(
		athlete_id,
		last_backload_activity_start,
	    last_load_attempt,
		last_load_incomplete,
		last_load_error,
		activites_loaded_last_attempt,
		earliest_activity,
		earliest_activity_done
	)
VALUES
	($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT
	(athlete_id)
DO UPDATE SET
	last_backload_activity_start = $2,
	last_load_attempt = $3,
	last_load_incomplete = $4,
	last_load_error = $5,
	activites_loaded_last_attempt = $6,
	earliest_activity = $7,
	earliest_activity_done = $8
RETURNING athlete_id, last_backload_activity_start, last_load_attempt, last_load_incomplete, last_load_error, activites_loaded_last_attempt, earliest_activity, earliest_activity_done
`

type UpsertAthleteLoadParams struct {
	AthleteID                  int64     `db:"athlete_id" json:"athlete_id"`
	LastBackloadActivityStart  time.Time `db:"last_backload_activity_start" json:"last_backload_activity_start"`
	LastLoadAttempt            time.Time `db:"last_load_attempt" json:"last_load_attempt"`
	LastLoadIncomplete         bool      `db:"last_load_incomplete" json:"last_load_incomplete"`
	LastLoadError              string    `db:"last_load_error" json:"last_load_error"`
	ActivitesLoadedLastAttempt int32     `db:"activites_loaded_last_attempt" json:"activites_loaded_last_attempt"`
	EarliestActivity           time.Time `db:"earliest_activity" json:"earliest_activity"`
	EarliestActivityDone       bool      `db:"earliest_activity_done" json:"earliest_activity_done"`
}

func (q *sqlQuerier) UpsertAthleteLoad(ctx context.Context, arg UpsertAthleteLoadParams) (AthleteLoad, error) {
	row := q.db.QueryRowContext(ctx, upsertAthleteLoad,
		arg.AthleteID,
		arg.LastBackloadActivityStart,
		arg.LastLoadAttempt,
		arg.LastLoadIncomplete,
		arg.LastLoadError,
		arg.ActivitesLoadedLastAttempt,
		arg.EarliestActivity,
		arg.EarliestActivityDone,
	)
	var i AthleteLoad
	err := row.Scan(
		&i.AthleteID,
		&i.LastBackloadActivityStart,
		&i.LastLoadAttempt,
		&i.LastLoadIncomplete,
		&i.LastLoadError,
		&i.ActivitesLoadedLastAttempt,
		&i.EarliestActivity,
		&i.EarliestActivityDone,
	)
	return i, err
}

const upsertAthleteLogin = `-- name: UpsertAthleteLogin :one
INSERT INTO
	athlete_logins(
		created_at, updated_at, id,
             athlete_id, summit, provider_id, oauth_access_token,
             oauth_refresh_token, oauth_expiry, oauth_token_type
	)
VALUES
    (Now(), Now(), gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7)
ON CONFLICT
	(athlete_id)
DO UPDATE SET
	updated_at = Now(),
	summit = $2,
	provider_id = $3,
	oauth_access_token = $4,
	oauth_refresh_token = $5,
	oauth_expiry = $6,
	oauth_token_type = $7
RETURNING athlete_id, summit, provider_id, created_at, updated_at, oauth_access_token, oauth_refresh_token, oauth_expiry, oauth_token_type, id
`

type UpsertAthleteLoginParams struct {
	AthleteID         int64     `db:"athlete_id" json:"athlete_id"`
	Summit            bool      `db:"summit" json:"summit"`
	ProviderID        string    `db:"provider_id" json:"provider_id"`
	OauthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OauthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OauthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
	OauthTokenType    string    `db:"oauth_token_type" json:"oauth_token_type"`
}

func (q *sqlQuerier) UpsertAthleteLogin(ctx context.Context, arg UpsertAthleteLoginParams) (AthleteLogin, error) {
	row := q.db.QueryRowContext(ctx, upsertAthleteLogin,
		arg.AthleteID,
		arg.Summit,
		arg.ProviderID,
		arg.OauthAccessToken,
		arg.OauthRefreshToken,
		arg.OauthExpiry,
		arg.OauthTokenType,
	)
	var i AthleteLogin
	err := row.Scan(
		&i.AthleteID,
		&i.Summit,
		&i.ProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthAccessToken,
		&i.OauthRefreshToken,
		&i.OauthExpiry,
		&i.OauthTokenType,
		&i.ID,
	)
	return i, err
}

const getCompetitiveRoute = `-- name: GetCompetitiveRoute :one
SELECT
	competitive_routes.name, competitive_routes.display_name, competitive_routes.description, (
	SELECT
		json_agg(
			json_build_object(
				'id',segments.id,
				'name',segments.name
			)
		) AS segment_summaries
	FROM
		segments
	WHERE
		id = ANY(competitive_routes.segments)
)
FROM
	competitive_routes
WHERE
	competitive_routes.name = $1
LIMIT 1
`

type GetCompetitiveRouteRow struct {
	Name             string          `db:"name" json:"name"`
	DisplayName      string          `db:"display_name" json:"display_name"`
	Description      string          `db:"description" json:"description"`
	SegmentSummaries json.RawMessage `db:"segment_summaries" json:"segment_summaries"`
}

func (q *sqlQuerier) GetCompetitiveRoute(ctx context.Context, routeName string) (GetCompetitiveRouteRow, error) {
	row := q.db.QueryRowContext(ctx, getCompetitiveRoute, routeName)
	var i GetCompetitiveRouteRow
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.SegmentSummaries,
	)
	return i, err
}

const hugelLeaderboard = `-- name: HugelLeaderboard :many
SELECT
	(SELECT min(total_time_seconds) FROM hugel_activities) :: BIGINT AS best_time,
	ROW_NUMBER() over(ORDER BY total_time_seconds ASC) AS rank,
	athlete_bests.activity_id,
	athlete_bests.athlete_id,
	athlete_bests.total_time_seconds,
	athlete_bests.efforts,

	activity_summary.name,
	activity_summary.distance,
	activity_summary.moving_time,
	activity_summary.elapsed_time,
	activity_summary.total_elevation_gain,
	activity_summary.start_date,

	athletes.firstname,
	athletes.lastname,
	athletes.username,
	athletes.profile_pic_link,
	athletes.sex
FROM
	(
		SELECT DISTINCT ON (athlete_id)
			activity_id, athlete_id, segment_ids, total_time_seconds, efforts
		FROM
			hugel_activities
		ORDER BY
			athlete_id, total_time_seconds ASC
	) AS athlete_bests
INNER JOIN
	athletes ON athlete_bests.athlete_id = athletes.id
INNER JOIN
	activity_summary ON athlete_bests.activity_id = activity_summary.id
WHERE
    CASE WHEN $1 > 0 THEN athlete_bests.athlete_id = $1 ELSE TRUE END
ORDER BY
    total_time_seconds ASC
`

type HugelLeaderboardRow struct {
	BestTime           int64           `db:"best_time" json:"best_time"`
	Rank               int64           `db:"rank" json:"rank"`
	ActivityID         int64           `db:"activity_id" json:"activity_id"`
	AthleteID          int64           `db:"athlete_id" json:"athlete_id"`
	TotalTimeSeconds   int64           `db:"total_time_seconds" json:"total_time_seconds"`
	Efforts            json.RawMessage `db:"efforts" json:"efforts"`
	Name               string          `db:"name" json:"name"`
	Distance           float64         `db:"distance" json:"distance"`
	MovingTime         float64         `db:"moving_time" json:"moving_time"`
	ElapsedTime        float64         `db:"elapsed_time" json:"elapsed_time"`
	TotalElevationGain float64         `db:"total_elevation_gain" json:"total_elevation_gain"`
	StartDate          time.Time       `db:"start_date" json:"start_date"`
	Firstname          string          `db:"firstname" json:"firstname"`
	Lastname           string          `db:"lastname" json:"lastname"`
	Username           string          `db:"username" json:"username"`
	ProfilePicLink     string          `db:"profile_pic_link" json:"profile_pic_link"`
	Sex                string          `db:"sex" json:"sex"`
}

func (q *sqlQuerier) HugelLeaderboard(ctx context.Context, athleteID interface{}) ([]HugelLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, hugelLeaderboard, athleteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HugelLeaderboardRow
	for rows.Next() {
		var i HugelLeaderboardRow
		if err := rows.Scan(
			&i.BestTime,
			&i.Rank,
			&i.ActivityID,
			&i.AthleteID,
			&i.TotalTimeSeconds,
			&i.Efforts,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.StartDate,
			&i.Firstname,
			&i.Lastname,
			&i.Username,
			&i.ProfilePicLink,
			&i.Sex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMapData = `-- name: UpsertMapData :one
INSERT INTO
	maps(
	updated_at, id, polyline, summary_polyline
)
VALUES
	(Now(), $1, $2, $3)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		polyline =
		    CASE
				WHEN $2 != '' THEN $2
		        ELSE maps.polyline
			END,
		summary_polyline =
			CASE
				WHEN $3 != '' THEN $3
				ELSE maps.summary_polyline
			END
RETURNING id, polyline, summary_polyline, updated_at
`

type UpsertMapDataParams struct {
	ID              string `db:"id" json:"id"`
	Polyline        string `db:"polyline" json:"polyline"`
	SummaryPolyline string `db:"summary_polyline" json:"summary_polyline"`
}

func (q *sqlQuerier) UpsertMapData(ctx context.Context, arg UpsertMapDataParams) (Map, error) {
	row := q.db.QueryRowContext(ctx, upsertMapData, arg.ID, arg.Polyline, arg.SummaryPolyline)
	var i Map
	err := row.Scan(
		&i.ID,
		&i.Polyline,
		&i.SummaryPolyline,
		&i.UpdatedAt,
	)
	return i, err
}

const allCompetitiveRoutes = `-- name: AllCompetitiveRoutes :many
SELECT name, display_name, description, segments FROM competitive_routes
`

func (q *sqlQuerier) AllCompetitiveRoutes(ctx context.Context) ([]CompetitiveRoute, error) {
	rows, err := q.db.QueryContext(ctx, allCompetitiveRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompetitiveRoute
	for rows.Next() {
		var i CompetitiveRoute
		if err := rows.Scan(
			&i.Name,
			&i.DisplayName,
			&i.Description,
			pq.Array(&i.Segments),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bestRouteEfforts = `-- name: BestRouteEfforts :many
SELECT
	merged.activities_id, segment_ids, sum, json_agg, hugel_efforts.id, hugel_efforts.athlete_id, hugel_efforts.segment_id, hugel_efforts.name, hugel_efforts.elapsed_time, hugel_efforts.moving_time, hugel_efforts.start_date, hugel_efforts.start_date_local, hugel_efforts.distance, hugel_efforts.start_index, hugel_efforts.end_index, hugel_efforts.device_watts, hugel_efforts.average_watts, hugel_efforts.kom_rank, hugel_efforts.pr_rank, hugel_efforts.updated_at, hugel_efforts.activities_id, segment_efforts.id, segment_efforts.athlete_id, segment_efforts.segment_id, segment_efforts.name, segment_efforts.elapsed_time, segment_efforts.moving_time, segment_efforts.start_date, segment_efforts.start_date_local, segment_efforts.distance, segment_efforts.start_index, segment_efforts.end_index, segment_efforts.device_watts, segment_efforts.average_watts, segment_efforts.kom_rank, segment_efforts.pr_rank, segment_efforts.updated_at, segment_efforts.activities_id
FROM
	(
		SELECT
			hugel_efforts.activities_id,
			-- segment_ids is all the segments this activity has efforts on.
			-- Only segments in the provided list are considered.
			array_agg(segment_id) AS segment_ids,
			-- Sum is the total time of all the efforts.
			sum(elapsed_time),
			-- A json struct containing each effort details.
			json_agg(
					json_build_object(
					    	'effort_id', id,
							'segment_id', segment_id,
							'elapsed_time', elapsed_time,
							'device_watts', device_watts,
					    	'average_watts', average_watts
						)
				)
		FROM
			(
				-- This query returns only the best effort per (segment_id, activity_id)
				SELECT DISTINCT ON (activities_id, segment_id)
					id, athlete_id, segment_id, name, elapsed_time, moving_time, start_date, start_date_local, distance, start_index, end_index, device_watts, average_watts, kom_rank, pr_rank, updated_at, activities_id
				FROM
					segment_efforts
				WHERE
				    -- ARRAY[629046, 6744304, 910045, 628785, 629546, 628842]
					segment_id = any($1 :: bigint[])
				ORDER BY
					activities_id, segment_id, elapsed_time ASC
			) as hugel_efforts
			-- Each activity will now be represented by a single aggregated row
		GROUP BY
			hugel_efforts.activities_id
	) AS merged
WHERE
	segment_ids @> $1 :: bigint[]
`

type BestRouteEffortsRow struct {
	ActivitiesID     int64           `db:"activities_id" json:"activities_id"`
	SegmentIds       interface{}     `db:"segment_ids" json:"segment_ids"`
	Sum              int64           `db:"sum" json:"sum"`
	JsonAgg          json.RawMessage `db:"json_agg" json:"json_agg"`
	ID               int64           `db:"id" json:"id"`
	AthleteID        int64           `db:"athlete_id" json:"athlete_id"`
	SegmentID        int64           `db:"segment_id" json:"segment_id"`
	Name             string          `db:"name" json:"name"`
	ElapsedTime      float64         `db:"elapsed_time" json:"elapsed_time"`
	MovingTime       float64         `db:"moving_time" json:"moving_time"`
	StartDate        time.Time       `db:"start_date" json:"start_date"`
	StartDateLocal   time.Time       `db:"start_date_local" json:"start_date_local"`
	Distance         float64         `db:"distance" json:"distance"`
	StartIndex       int32           `db:"start_index" json:"start_index"`
	EndIndex         int32           `db:"end_index" json:"end_index"`
	DeviceWatts      bool            `db:"device_watts" json:"device_watts"`
	AverageWatts     float64         `db:"average_watts" json:"average_watts"`
	KomRank          sql.NullInt32   `db:"kom_rank" json:"kom_rank"`
	PrRank           sql.NullInt32   `db:"pr_rank" json:"pr_rank"`
	UpdatedAt        time.Time       `db:"updated_at" json:"updated_at"`
	ActivitiesID_2   int64           `db:"activities_id_2" json:"activities_id_2"`
	ID_2             int64           `db:"id_2" json:"id_2"`
	AthleteID_2      int64           `db:"athlete_id_2" json:"athlete_id_2"`
	SegmentID_2      int64           `db:"segment_id_2" json:"segment_id_2"`
	Name_2           string          `db:"name_2" json:"name_2"`
	ElapsedTime_2    float64         `db:"elapsed_time_2" json:"elapsed_time_2"`
	MovingTime_2     float64         `db:"moving_time_2" json:"moving_time_2"`
	StartDate_2      time.Time       `db:"start_date_2" json:"start_date_2"`
	StartDateLocal_2 time.Time       `db:"start_date_local_2" json:"start_date_local_2"`
	Distance_2       float64         `db:"distance_2" json:"distance_2"`
	StartIndex_2     int32           `db:"start_index_2" json:"start_index_2"`
	EndIndex_2       int32           `db:"end_index_2" json:"end_index_2"`
	DeviceWatts_2    bool            `db:"device_watts_2" json:"device_watts_2"`
	AverageWatts_2   float64         `db:"average_watts_2" json:"average_watts_2"`
	KomRank_2        sql.NullInt32   `db:"kom_rank_2" json:"kom_rank_2"`
	PrRank_2         sql.NullInt32   `db:"pr_rank_2" json:"pr_rank_2"`
	UpdatedAt_2      time.Time       `db:"updated_at_2" json:"updated_at_2"`
	ActivitiesID_3   int64           `db:"activities_id_3" json:"activities_id_3"`
}

// BestRouteEfforts returns all activities that have efforts on all the provided segments.
// The returned activities include the best effort for each segment.
func (q *sqlQuerier) BestRouteEfforts(ctx context.Context, expectedSegments []int64) ([]BestRouteEffortsRow, error) {
	rows, err := q.db.QueryContext(ctx, bestRouteEfforts, pq.Array(expectedSegments))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BestRouteEffortsRow
	for rows.Next() {
		var i BestRouteEffortsRow
		if err := rows.Scan(
			&i.ActivitiesID,
			&i.SegmentIds,
			&i.Sum,
			&i.JsonAgg,
			&i.ID,
			&i.AthleteID,
			&i.SegmentID,
			&i.Name,
			&i.ElapsedTime,
			&i.MovingTime,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Distance,
			&i.StartIndex,
			&i.EndIndex,
			&i.DeviceWatts,
			&i.AverageWatts,
			&i.KomRank,
			&i.PrRank,
			&i.UpdatedAt,
			&i.ActivitiesID_2,
			&i.ID_2,
			&i.AthleteID_2,
			&i.SegmentID_2,
			&i.Name_2,
			&i.ElapsedTime_2,
			&i.MovingTime_2,
			&i.StartDate_2,
			&i.StartDateLocal_2,
			&i.Distance_2,
			&i.StartIndex_2,
			&i.EndIndex_2,
			&i.DeviceWatts_2,
			&i.AverageWatts_2,
			&i.KomRank_2,
			&i.PrRank_2,
			&i.UpdatedAt_2,
			&i.ActivitiesID_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadedSegments = `-- name: LoadedSegments :many
SELECT id, fetched_at FROM segments
`

type LoadedSegmentsRow struct {
	ID        int64     `db:"id" json:"id"`
	FetchedAt time.Time `db:"fetched_at" json:"fetched_at"`
}

func (q *sqlQuerier) LoadedSegments(ctx context.Context) ([]LoadedSegmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, loadedSegments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadedSegmentsRow
	for rows.Next() {
		var i LoadedSegmentsRow
		if err := rows.Scan(&i.ID, &i.FetchedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSegment = `-- name: UpsertSegment :one
INSERT INTO
	segments(
	id, name, activity_type, distance, average_grade,
	maximum_grade, elevation_high, elevation_low, start_latlng, end_latlng,
	elevation_profile, climb_category, city, state, country, private, hazardous,
	created_at, updated_at, total_elevation_gain, map_id, total_effort_count,
	total_athlete_count, total_star_count, fetched_at
	)
VALUES
	($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
	 $18, $19, $20, $21, $22, $23, $24, Now())
ON CONFLICT
	(id)
	DO UPDATE SET
	name = CASE WHEN $2 != '' THEN $2 ELSE segments.name END,
	activity_type = CASE WHEN $3 != '' THEN $3 ELSE segments.activity_type END,
	distance = CASE WHEN $4 != 0 THEN $4 ELSE segments.distance END,
	average_grade = CASE WHEN $5 != 0 THEN $5 ELSE segments.average_grade END,
	maximum_grade = CASE WHEN $6 != 0 THEN $6 ELSE segments.maximum_grade END,
	elevation_high = CASE WHEN $7 != 0 THEN $7 ELSE segments.elevation_high END,
	elevation_low = CASE WHEN $8 != 0 THEN $8 ELSE segments.elevation_low END,
	start_latlng = $9,
	end_latlng = $10,
	elevation_profile = CASE WHEN $11 != '' THEN $11 ELSE segments.elevation_profile END,
	climb_category = CASE WHEN $12 != 0 THEN $12 ELSE segments.climb_category END,
	city = CASE WHEN $13 != '' THEN $13 ELSE segments.city END,
	state = CASE WHEN $14 != '' THEN $14 ELSE segments.state END,
	country = CASE WHEN $15 != '' THEN $15 ELSE segments.country END,
	private = $16,
	hazardous = $17,
	created_at = CASE WHEN $18 != '0001-01-01 00:00:00+00' THEN $18 ELSE segments.created_at END,
	updated_at = CASE WHEN $19 != '0001-01-01 00:00:00+00' THEN $18 ELSE segments.updated_at END,
	total_elevation_gain = CASE WHEN $20 != 0 THEN $20 ELSE segments.total_elevation_gain END,
	map_id = CASE WHEN $21 != '' THEN $21 ELSE segments.map_id END,
	total_effort_count = CASE WHEN $22 != 0 THEN $22 ELSE segments.total_effort_count END,
	total_athlete_count = CASE WHEN $23 != 0 THEN $23 ELSE segments.total_athlete_count END,
	total_star_count = CASE WHEN $24 != 0 THEN $24 ELSE segments.total_star_count END,
	fetched_at = Now()

RETURNING id, name, activity_type, distance, average_grade, maximum_grade, elevation_high, elevation_low, start_latlng, end_latlng, elevation_profile, climb_category, city, state, country, private, hazardous, created_at, updated_at, total_elevation_gain, map_id, total_effort_count, total_athlete_count, total_star_count, fetched_at
`

type UpsertSegmentParams struct {
	ID                 int64     `db:"id" json:"id"`
	Name               string    `db:"name" json:"name"`
	ActivityType       string    `db:"activity_type" json:"activity_type"`
	Distance           float64   `db:"distance" json:"distance"`
	AverageGrade       float64   `db:"average_grade" json:"average_grade"`
	MaximumGrade       float64   `db:"maximum_grade" json:"maximum_grade"`
	ElevationHigh      float64   `db:"elevation_high" json:"elevation_high"`
	ElevationLow       float64   `db:"elevation_low" json:"elevation_low"`
	StartLatlng        []float64 `db:"start_latlng" json:"start_latlng"`
	EndLatlng          []float64 `db:"end_latlng" json:"end_latlng"`
	ElevationProfile   string    `db:"elevation_profile" json:"elevation_profile"`
	ClimbCategory      int32     `db:"climb_category" json:"climb_category"`
	City               string    `db:"city" json:"city"`
	State              string    `db:"state" json:"state"`
	Country            string    `db:"country" json:"country"`
	Private            bool      `db:"private" json:"private"`
	Hazardous          bool      `db:"hazardous" json:"hazardous"`
	CreatedAt          time.Time `db:"created_at" json:"created_at"`
	UpdatedAt          time.Time `db:"updated_at" json:"updated_at"`
	TotalElevationGain float64   `db:"total_elevation_gain" json:"total_elevation_gain"`
	MapID              string    `db:"map_id" json:"map_id"`
	TotalEffortCount   int32     `db:"total_effort_count" json:"total_effort_count"`
	TotalAthleteCount  int32     `db:"total_athlete_count" json:"total_athlete_count"`
	TotalStarCount     int32     `db:"total_star_count" json:"total_star_count"`
}

func (q *sqlQuerier) UpsertSegment(ctx context.Context, arg UpsertSegmentParams) (Segment, error) {
	row := q.db.QueryRowContext(ctx, upsertSegment,
		arg.ID,
		arg.Name,
		arg.ActivityType,
		arg.Distance,
		arg.AverageGrade,
		arg.MaximumGrade,
		arg.ElevationHigh,
		arg.ElevationLow,
		pq.Array(arg.StartLatlng),
		pq.Array(arg.EndLatlng),
		arg.ElevationProfile,
		arg.ClimbCategory,
		arg.City,
		arg.State,
		arg.Country,
		arg.Private,
		arg.Hazardous,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.TotalElevationGain,
		arg.MapID,
		arg.TotalEffortCount,
		arg.TotalAthleteCount,
		arg.TotalStarCount,
	)
	var i Segment
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ActivityType,
		&i.Distance,
		&i.AverageGrade,
		&i.MaximumGrade,
		&i.ElevationHigh,
		&i.ElevationLow,
		pq.Array(&i.StartLatlng),
		pq.Array(&i.EndLatlng),
		&i.ElevationProfile,
		&i.ClimbCategory,
		&i.City,
		&i.State,
		&i.Country,
		&i.Private,
		&i.Hazardous,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TotalElevationGain,
		&i.MapID,
		&i.TotalEffortCount,
		&i.TotalAthleteCount,
		&i.TotalStarCount,
		&i.FetchedAt,
	)
	return i, err
}

const upsertSegmentEffort = `-- name: UpsertSegmentEffort :one
INSERT INTO
	segment_efforts(
		updated_at,
		id, athlete_id, segment_id, name, elapsed_time,
		moving_time, start_date, start_date_local, distance,
		start_index, end_index, device_watts, average_watts,
		kom_rank, pr_rank, activities_id
	)
VALUES
	(Now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
ON CONFLICT
	(id)
	DO UPDATE SET
		updated_at = Now(),
		athlete_id = $2,
		segment_id = $3,
		name = $4,
		elapsed_time = $5,
		moving_time = $6,
		start_date = $7,
		start_date_local = $8,
		distance = $9,
		start_index = $10,
		end_index = $11,
		device_watts = $12,
		average_watts = $13,
		kom_rank = $14,
		pr_rank = $15,
		activities_id = $16
	RETURNING id, athlete_id, segment_id, name, elapsed_time, moving_time, start_date, start_date_local, distance, start_index, end_index, device_watts, average_watts, kom_rank, pr_rank, updated_at, activities_id
`

type UpsertSegmentEffortParams struct {
	ID             int64         `db:"id" json:"id"`
	AthleteID      int64         `db:"athlete_id" json:"athlete_id"`
	SegmentID      int64         `db:"segment_id" json:"segment_id"`
	Name           string        `db:"name" json:"name"`
	ElapsedTime    float64       `db:"elapsed_time" json:"elapsed_time"`
	MovingTime     float64       `db:"moving_time" json:"moving_time"`
	StartDate      time.Time     `db:"start_date" json:"start_date"`
	StartDateLocal time.Time     `db:"start_date_local" json:"start_date_local"`
	Distance       float64       `db:"distance" json:"distance"`
	StartIndex     int32         `db:"start_index" json:"start_index"`
	EndIndex       int32         `db:"end_index" json:"end_index"`
	DeviceWatts    bool          `db:"device_watts" json:"device_watts"`
	AverageWatts   float64       `db:"average_watts" json:"average_watts"`
	KomRank        sql.NullInt32 `db:"kom_rank" json:"kom_rank"`
	PrRank         sql.NullInt32 `db:"pr_rank" json:"pr_rank"`
	ActivitiesID   int64         `db:"activities_id" json:"activities_id"`
}

func (q *sqlQuerier) UpsertSegmentEffort(ctx context.Context, arg UpsertSegmentEffortParams) (SegmentEffort, error) {
	row := q.db.QueryRowContext(ctx, upsertSegmentEffort,
		arg.ID,
		arg.AthleteID,
		arg.SegmentID,
		arg.Name,
		arg.ElapsedTime,
		arg.MovingTime,
		arg.StartDate,
		arg.StartDateLocal,
		arg.Distance,
		arg.StartIndex,
		arg.EndIndex,
		arg.DeviceWatts,
		arg.AverageWatts,
		arg.KomRank,
		arg.PrRank,
		arg.ActivitiesID,
	)
	var i SegmentEffort
	err := row.Scan(
		&i.ID,
		&i.AthleteID,
		&i.SegmentID,
		&i.Name,
		&i.ElapsedTime,
		&i.MovingTime,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Distance,
		&i.StartIndex,
		&i.EndIndex,
		&i.DeviceWatts,
		&i.AverageWatts,
		&i.KomRank,
		&i.PrRank,
		&i.UpdatedAt,
		&i.ActivitiesID,
	)
	return i, err
}

const insertWebhookDump = `-- name: InsertWebhookDump :one
INSERT INTO
	webhook_dump(
	id, recorded_at, raw
)
VALUES
	(gen_random_uuid(), Now(), $1)
RETURNING id, recorded_at, raw
`

func (q *sqlQuerier) InsertWebhookDump(ctx context.Context, rawJson string) (WebhookDump, error) {
	row := q.db.QueryRowContext(ctx, insertWebhookDump, rawJson)
	var i WebhookDump
	err := row.Scan(&i.ID, &i.RecordedAt, &i.Raw)
	return i, err
}
